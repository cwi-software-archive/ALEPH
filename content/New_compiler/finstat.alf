'EXTERNAL' 'ACTION' NLCR, PRSYM, ACKNOWLEDGE.
'MACRO' 'ACTION' PRINT ='FIXT(8,0,''1'), GET SYM = '1':=RESYMBOL.
'MACRO' 'POINTER' NIL = (-2), OTHER = (-1), MAX CODE = 255,
    NIX = 255, EOF = (-4096).
'MACRO' 'FUNCTION' ADD = '3':='1'+'2', SUBTR = '3':='1'-'2',
    INCR = '1':='1'+1.
'MACRO' 'QUESTION' LESS = '1'<'2', LSEQ = '1'_<'2'.
'LIST'  [100 001 : 101 000] TEXT(CHAR, STACK),
        [200 001 : 200 256] CONV,
        [300 001 : 310 000] CHAR ST,
        [400 001 : 401 000] REC ST (ITEM, NEXT),
        [500 001 : 500 100] ITEM.
'MACRO' 'POINTER' MIN TEXT = 100 000, MIN CONV = 200 000, CONV BASE = 200 001,
  MIN CHAR ST = 300 000, MIN REC ST = 400 000, MIN ITEM = 500 000.
'POINTER' MAX TEXT, MAX CONV, MAX CHAR ST, MAX REC ST, MAX ITEM.
'POINTER' SB TEXT, SB CONV, SB CHAR ST, SB REC ST, SB ITEM.
'MACRO' 'ACTION' NEXT = '2' := '2' + SB'1'.
'MACRO' 'QUESTION'
  WAS TEXT =    '1'_:100000 = 1,
  WAS CONV =    '1'_:100000 = 2,
  WAS CHAR ST = '1'_:100000 = 3,
  WAS REC ST  = '1'_:100000 = 4,
  WAS ITEM =    '1'_:100000 = 5.
'POINTER' MAX CHAR, STANDARD.
'ACTION' INITIALIZE, READ ITEMS, READ ITEM, GET TERMINATOR,
  SOME TEXT, ENTER AND CONV, SET UP TABLES, CLAIM STANDARD STACK,
  NUMBER STACKS, CLAIM STACK, FILL STATES, ACCOMODATE SUBSTACK,
  ENTER STATE, UPDATE, ERROR, RUN, SYMBOL, SUBSTACKS.
'ACTION' DUMP, DUMP CONV, DUMP CHAR ST, DUMP TEXT, DUMP REC ST, DUMP ITEM.
'QUESTION'
  LAYOUT + SYM: SYM = 93; SYM = 118; SYM = 119.
'ACTION'
CLAIM TEXT + CHAR + STACK:
  ADD + MAX TEXT + 2 + MAX TEXT, CHAR -> CHAR*TEXT[MAX TEXT],
  STACK -> STACK*TEXT[MAX TEXT].
'ACTION'
CLAIM CONV + CONV1:
  ADD + MAX CONV + 1 + MAX CONV, CONV1 -> CONV[MAX CONV].
'ACTION'
CLAIM CHAR ST + ST:
  ADD + MAX CHAR ST + 1 + MAX CHAR ST, ST -> CHAR ST[MAX CHAR ST].
'ACTION'
CLAIM REC ST + ITEM1 + NEXT1:
  ADD + MAX REC ST + 2 + MAX REC ST, NEXT1 -> NEXT*RECST[MAX REC ST],
  ITEM1 -> ITEM*REC ST[MAX REC ST].
'ACTION'
CLAIM ITEM + ITEM1:
  ADD + MAX ITEM + 1 + MAX ITEM, ITEM1 -> ITEM[MAX ITEM].
'ACTION'
FILL CONV - N:
  0 -> N, FILL:( N = MAX CODE; CLAIM CONV + OTHER, INCR + N, :FILL).
$ PROGRAM
$

'ACTION'
FINITE STATE RECOGNIZER:
  INITIALIZE, READ ITEMS, DUMP, SET UP TABLES, DUMP, RUN.
'ACTION'
INITIALIZE:
  100000 -> MAX TEXT, 200000 -> MAX CONV, 300000 -> MAX CHAR ST,
  400000 -> MAX REC ST, 500000 -> MAX ITEM,
  2 -> SB TEXT, 1 -> SB CONV, 1 -> SB CHAR ST, 2 -> SB REC ST, 1 -> SB ITEM,
  0 -> MAX CHAR, MIN CHAR ST -> STANDARD, FILL CONV.
$ INPUT
$
'ACTION'
READ ITEMS - RES:
  READ ITEM + RES,
   (RES = NIL;
    CLAIM ITEM + RES, MAX ITEM -> STACK*TEXT[MAX TEXT], :READ ITEMS).
'ACTION'
READ ITEM + >RES - TERM:
  GET TERMINATOR + TERM, SOME TEXT + TERM + RES.
'ACTION'
GET TERMINATOR + >TERM:
  GET SYM + TERM, (LAYOUT + TERM, :GET TERMINATOR; +).
'ACTION'
SOME TEXT + TERM + >RES - SYM:
  GET SYM + SYM,
   (SYM = TERM, NIL -> RES;
    MAX TEXT -> RES,
    TXT:
     (ENTER AND CONV + SYM, CLAIM TEXT + SYM + NIL, GET SYM + SYM,
       (SYM = TERM; :TXT))
   ).
'ACTION'
ENTER AND CONV + >SYM>:
  ADD + SYM + CONV BASE + SYM,
   (CONV[SYM] = OTHER, INCR + MAX CHAR, MAX CHAR -> CONV[SYM] -> SYM;
    CONV[SYM] -> SYM).
$ PROCESS INPUT
$

'ACTION'
SET UP TABLES:
  CLAIM STANDARD STACK, NUMBER STACKS, FILL STATES.
'ACTION'
CLAIM STANDARD STACK:
  CLAIM STACK.
'ACTION'
NUMBER STACKS - PR ITEM - END - RES:
  MIN ITEM -> PR ITEM,
  ITEMS:
   (PR ITEM = MAX ITEM;
    NEXT + ITEM + PR ITEM, ITEM[PR ITEM] -> END,
    STACKS:
     (NEXT + TEXT + END,
       (WAS ITEM + STACK*TEXT[END];
        WAS OLD STACK + PR ITEM + END + RES, RES -> STACK*TEXT[END], :STACKS;
        MAX CHAR ST -> STACK*TEXT[END], CLAIM STACK, :STACKS)),
    :ITEMS).
'QUESTION'
WAS OLD STACK + TEXT ITEM + END + >RES - ITEM1 - END1:
  MIN ITEM -> ITEM1,
  TRY TEXTS:
   (NEXT + ITEM + ITEM1, LESS + ITEM1 + TEXT ITEM,
     ((IS EQUAL TEXT + ITEM[TEXT ITEM] + END + ITEM[ITEM1] + END1,
        WAS CHAR ST + STACK*TEXT[END1]), STACK*TEXT[END1] -> RES;
      :TRY TEXTS)
   ).
'QUESTION'
IS EQUAL TEXT + FROM1 + TO1 + FROM2 + >TO2:
  FROM1 = TO1, FROM2 -> TO2;
  COMPARE:
   (NEXT + TEXT + FROM1, NEXT + TEXT + FROM2,
      CHAR*TEXT[FROM1] = CHAR*TEXT[FROM2],
     (FROM1 = TO1, FROM2 -> TO2;
      WAS CHAR ST + STACK*TEXT[FROM2], : COMPARE)).
'ACTION'
CLAIM STACK - CNT:
  0 -> CNT,
  CLAIM: (CNT = MAX CHAR; CLAIM CHAR ST + STANDARD, INCR + CNT, :CLAIM).

$

'ACTION'
FILL STATES - PR ITEM - END - STATE:
  MIN ITEM -> PR ITEM,
  ITEMS:
   (PR ITEM = MAX ITEM;
    NEXT + ITEM + PR ITEM, ITEM[PR ITEM] -> END, STANDARD -> STATE,
    STACKS:
     (SUBSTACKS + PR ITEM + END + STATE,
      NEXT + TEXT + END,
       (WAS CHAR ST + STACK*TEXT[END], STACK*TEXT[END] -> STATE, :STACKS; +)),
    :ITEMS).
'ACTION'
SUBSTACKS + PR ITEM + END + STATE - BEGIN - DUMMY:
  WAS OLD STACK + PR ITEM + END + DUMMY;
  ITEM[PR ITEM] -> BEGIN,
  SUBSTACKS:
   (ACCOMODATE SUBSTACK + BEGIN + END + STATE,
     (BEGIN = END; NEXT + TEXT + BEGIN, :SUBSTACK)).
'ACTION'
ACCOMODATE SUBSTACK + FROM + TO + STATE - PR ITEM - POS:
  MIN ITEM -> PR ITEM,
  ITEMS:
   (PR ITEM = MAX ITEM;
    NEXT + ITEM + PR ITEM,
     (IS EQUAL TEXT + FROM + TO + ITEM[PR ITEM] + POS,
        ENTER STATE + POS + STATE; +),
    :ITEMS).
'ACTION'
ENTER STATE + TEXT ITEM + STATE - NEW STATE - POS - LAST:
  NEXT + TEXT + TEXT ITEM, STACK*TEXT[TEXT ITEM] -> NEW STATE,
  ADD + STATE + CHAR*TEXT[TEXT ITEM] + POS,
   (END FOUND + NEW STATE + CHAR ST[POS], CHAR ST[POS] -> LAST;
    CHAR ST[POS] -> POS,
    CHAIN:
     (END FOUND + NEW STATE + NEXT*REC ST[POS], NEXT*REC ST[POS] -> LAST;
      NEXT*REC ST[POS] -> POS, :CHAIN)),
   (WAS ITEM + NEW STATE,
      CLAIM REC ST + NEW STATE + LAST, UPDATE + POS + MAX REC ST;
    LAST = STANDARD, UPDATE + POS + NEW STATE;
   +).
'QUESTION'
END FOUND + STOP STATE + PROPOSED:
                         WAS CHAR ST + PROPOSED.
'ACTION'
UPDATE + POS + VAL:
  WAS CHAR ST + POS, VAL -> CHAR ST[POS];
  WAS REC ST + POS, VAL -> NEXT*REC ST[POS]; ERROR + 10 + POS.
'FUNCTION'
ERROR + TYPE + DATA:
  NLCR, NLCR, PRSYM + 14, PRSYM + 27, PRINT + TYPE, PRINT + DATA, NLCR, NLCR.

$
$

'ACTION'
RUN - SYM - STATE:
  STANDARD -> STATE,
  SYMBOLS:
   (SYMBOL + SYM,
     (SYM = NIX;
       (SYM = OTHER, STANDARD -> STATE;
        ADD + STATE + SYM + SYM, CHAR ST[SYM] -> STATE,
        REC STATES:
         (WAS REC ST + STATE, ACKNOWLEDGE + ITEM*REC ST[STATE],
            NEXT*REC ST[STATE] -> STATE, :REC STATES;
          +)),
        :SYMBOLS)
   ).
'ACTION'
SYMBOL + >SYM - CHAR:
  GET SYM+ CHAR,
   (CHAR = EOF, NIX -> SYM;
    LESS + CHAR + 0, ERROR + 20 + CHAR, :SYMBOL;
    PRSYM + CHAR, ADD + CONV BASE + CHAR + SYM, CONV[SYM] -> SYM).

'ACTION'
DUMP: DUMP CONV, DUMP ITEM, DUMP TEXT, DUMP CHAR ST, DUMP REC ST.
'ACTION'
DUMP CONV - S - PNT - CNT:
  NLCR, MIN CONV -> PNT, SUBTR + 0 + 1 + CNT,
  SYMB:
   (NEXT + CONV + PNT, INCR + CNT,
     (LSEQ + PNT + MAX CONV, CONV[PNT] -> S,
       (S = OTHER; NLCR, PRSYM + CNT, PRINT + S), :SYMB; +)).
'ACTION'
DUMP CHAR ST - PNT - CNT:
  NLCR, MIN CHAR ST -> PNT,
  STATE:
   (LESS + PNT + MAX CHAR ST, NLCR, PRINT + PNT, 0 -> CNT,
    ENT:
     (INCR + CNT, NEXT + CHAR ST + PNT, PRINT + CHAR ST[PNT],
       (CNT = MAX CHAR; :ENT)),
    :STATE; +).
'ACTION'
DUMP TEXT - CH:
    NLCR, MIN TEXT -> CH,
    CHARS:
       (CH = MAX TEXT;
        NEXT + TEXT + CH, NLCR,
          PRINT + CHAR * TEXT[CH], PRINT + STACK*TEXT[CH], :CHARS).
'ACTION'
DUMP REC ST - RS:
    NLCR, MIN REC ST -> RS,
    RECS:
       (RS = MAX REC ST;
        NEXT + REC ST + RS, NLCR,
          PRINT + ITEM*REC ST[RS], PRINT + NEXT*REC ST[RS], :RECS).
'ACTION'
DUMP ITEM - IT:
    NLCR, MIN ITEM -> IT,
    ITEMS:
       (IT = MAX ITEM;
        NEXT + ITEM + IT, NLCR, PRINT + ITEM[IT], :ITEMS).
'ROOT' FINITE STATE RECOGNIZER.
'PUNCHOFF'
