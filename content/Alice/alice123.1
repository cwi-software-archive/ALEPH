

.na
.ll 75
.lt 75
.pl 60
.de qq
.if o .tl '''%'
.if e .tl '%'''
.c2 |
|sp 3
.ns
..
.wh 0 qq
.c2|
.nh
.de p0
.ti 6
..
.de p1

.ti 6
..
.de p2


.ti 6
..
ALICE: An Exercise in Program Portability


by


A.P.W. Bohm




ABSTRACT


ALEPH has been designed at the Mathematical Centre as a tool for
compiler writing.
In the ALEPH compiler
a clear interface between the machine-independent
and the machine-dependent part is established. This interface presents
itself as an intermediate code, called ALICE.
ALICE can be implemented easily and efficiently on many machines.
This report defines ALICE, gives installation hints, and
states which design decisions were taken.































.nf
KEY WORDS & PHRASES:  ALEPH, abstract machine, intermediate code,
		      portability, adaptability, machine-independence
.bp




INDEX


0  Preface								  4

0.1  Informal and incomplete introduction to ALEPH			  5


1  The role of ALICE in the compilation of ALEPH programs		  8

1.1  Splitting up the ALEPH compiler					  8
1.2  Porting an ALEPH program to a new machine				  9


2  Outline of ALICE							 12

2.1  ALICE grammars							 12
2.2  The format of ALICE statements					 13
2.3  Features needed to translate ALICE					 14
2.4  The character set							 16
2.5  The simple ALICE grammar						 18
2.6  Example								 27



3  Description of the various constructs of ALICE			 29

3.1  Values								 29
3.1.1  The range of integer values					 30
3.1.2  The character code						 32
3.1.3  The address space						 33
3.1.4  Strings								 34
3.1.5  Example								 36
3.2  Data								 39
3.2.1  Integer								 39
3.2.1.1	 Constant source						 39
3.2.1.2	 Variable							 42
3.2.2  List								 43
3.2.2.1	 List area							 43
3.2.2.2	 List administration						 45
3.2.2.3	 External table							 47
3.2.3  File								 48
3.2.3.1	 File administration						 48
.bp
3.3  Rules								 51
3.3.1  Introduction							 51
3.3.2  The ALICE abstract machine					 53
3.3.3  Outline of an ALICE rule						 55
3.3.4  Rule head							 55
3.3.5  Rule tail							 57
3.3.6  Calling a rule							 60
3.3.7  Parameter passing						 62
3.3.7.1	 Actual input parameters					 62
3.3.7.2	 Actual output parameters					 67
3.3.8  Primitive rules							 71
3.3.8.1	 External rules							 71
3.3.8.2	 ALICE primitives						 73
3.4  Program structure							 78
3.5  ALICE grammar							 81


4  References								 99


.fi
.bp

0  Preface
.p2
At the moment this report is written, we have an ALEPH
compiler running happily on a CYBER under SCOPE 3.4.1.
This ALEPH compiler generates COMPASS, the assembly
language of the CYBER.
.p1
ALEPH was designed by people
working on the ALGOL 68 compiler at the Mathematical Centre. The most important
task of the ALEPH compiler is to compile this MC ALGOL 68
compiler, which is written in ALEPH.
The ALGOL 68 group is trying to develop a both
portable and adaptable compiler for the full language ALGOL 68.
.p1
A necessary condition for reaching this honourable goal is to have a
portable and adaptable ALEPH compiler as well.
The present ALEPH compiler does not meet this end, and therefore
it is being rewritten to establish a clear interface between
its machine-independent and its machine-dependent part.
.p1
Roughly speaking, the machine-independent part of the new compiler consists of a
parser and a semantic
analyzer; the machine-dependent part consists of a code generator.
The interface between these two parts presents itself as an
intermediate code. This intermediate code, called ALICE, can be
considered  the ultimate machine independent stage in the
translation of	ALEPH to machine code.
.p1
In a first version of the ALEPH compiler on a new machine,
ALICE is the output of the semantic analyzer, that is, it is written
on a file and read by  a translator from ALICE to machine code.
In a more progressed version ALICE is
merely a set of calls to code-generating routines.
More precisely, the semantic analyzer ends with calls to code generating
routines, which in the first case simply copy
the call to a file and in the second case generate code
for a particular machine.
.p1
Although this report is primarily meant for installers of the ALEPH
compiler, who must be familiar with ALEPH [1], it is self-contained. A
rather informal
and incomplete introduction to ALEPH is given below.
Chapter one of this report describes the role of ALICE
in the compilation process from ALEPH to machine code
in detail. Chapter two describes the
format of the ALICE statements
and the character
set in which ALICE programs are written.
Chapter two also mentions some programming tools which can be used to
to facilitate
the translation
from ALICE to machine code.
Chapter three contains a complete description of
the various constructions in ALICE.



.bp
0.1  Informal and incomplete introduction to ALEPH
.p2
For those not intending to implement ALEPH and unfamiliar
with it, a very informal and incomplete introduction into
its use now follows.
.p1
ALEPH is a simple programming language, based on two features:

1. Decomposition by means of a procedure mechanism. Procedures are
called "rules" in ALEPH.

2. Specification of alternatives within a rule.
.p1
ALEPH originated from the idea that a context-free grammar can be used
as a programming language, such as in the recursive descent parsing
method. For instance, the grammar for strict binary trees in parenthesized
infix notation:
.nf


tree		     : terminal node;
		       open symbol, tree, non terminal node, tree,
			    close symbol.

terminal node	     : letter.

non terminal node    : letter.

.fi
can be considered to have the following meaning:

there is a tree:
.br
either if there is a terminal node
.br
    or if there is  an open-symbol,  followed by  a tree,  followed by a
		    non-terminal-node, a tree, and a close-symbol.

.p1
An ALEPH program is a set of "rule declarations" and "data declarations".
Just as in a context-free grammar, there is one starting point called
the "root" of the program. The root calls one rule, which calls other rules,
and so the ALEPH machine comes into action.
A rule consists of a number of "alternatives". An alternative consists
of a number of "members". A member is either a language primitive, such as
an assignment, or a call to another rule.
.p1
The first member of an alternative can be considered as the key to that
alternative: if the key fits the other alternatives are no longer of
interest. To be able to serve as keys, members can fail or succeed.
A member succeeds if the rule it calls or the language primitive it
represents succeeds. A rule succeeds if one of its alternatives applies
and all members of that alternative succeed. A rule fails either if no
alternative applies or if an alternative applies but one of its members
fails.
Some rules do not have to be declared, but can be considered as built
in. Their names are known to the ALEPH compiler. These rules
are called external rules.
The recursive definition of success or failure of a member does not loop
because of the existence of the external rules and the language primitives.
.p1
For some rules in a program there will always be an alternative that
applies: these rules cannot fail. Therefore
rules can be divided in two groups: those that can fail and those that
cannot.
.p1
There is another criterion that divides rules in two groups: rules have
or have no "side effects". A rule has side effects if it changes the
environment (global data).
.p1
The division criteria can be combined, yielding four groups of rules:

.nf
can fail, has side effects	: 'predicate'
can fail, has no side effects	: 'question'
cannot fail, has side effects	: 'action'
cannot fail, has no side effects: 'function'
.fi
.p1
This information about a rule is given by the programmer
and checked by the compiler.
.p1
Communication between the members in a rule
and between callers and called rules
is done by parameters, called
"affixes".
Besides "formal" affixes a rule has "local" affixes
for scratch pad purposes.
Formal affixes are either prefilled at call entry (input parameters), or
used by the caller upon return (output parameters), or
both (input-output parameters).
Local affixes are uninitialized at call entry.
If the rule fails, the caller will not need the values of the output
affixes: they will not even be passed back at call exit.
.p2
As an example, part of a program that reads a sequence of numbers and prints
their sum is showed.


'root' read and print.

'action' read and print - sum:

	read + sum, print + sum.

'action' read + res>:

	number + res, rest numbers option + res.


'action' rest numbers option + >res> - nmb:

	comma symbol, number + nmb, plus + nmb + res + res,
		rest numbers option + res;
	+.


'action' number + res>:

	get int + input file + res;
	error + bad number, 0 -> res.


'action' print + >number:

	put int + output file + number.




.fi
.p2
The pluses connect the affixes to the rules. The minus signals a
local affix. The right arrow in front of "res" in "rest numbers option"
indicates that "res" is an input affix. The value of the actual affix
of the caller will be copied to the formal affix of the called
rule.
The right arrow at the back of "res" indicates that at rule exit
its value will be restored to the actual affix of the caller.
.p1
The local affix "sum" in "read and print" is uninitialized at the colon.
From the declaration of "read" it follows that it will return a
value to "sum".
After the call of "read", "sum" is initialized and can
be used by "print".
.p1
"get int" is an external predicate.
The programmer is forced to think about the exceptional
case end of file.
"0 -> res" assigns 0 to "res", as might have been expected.


Data types.
.p1
ALEPH restricts itself to integer data and stacks of these.
Global variables must be initialized upon declaration.
Stacks have
the usual property that top elements may be added, inspected and removed.
In addition, they have the following properties:
.br
a. All elements can be	reached; thus the stack can act as an array.
.br
b. Bottom elements can be removed; thus the stack can act as a queue.





.bp
1  The role of ALICE in the compilation of ALEPH programs


1.1  Splitting up the ALEPH compiler


.p1
The aim is an ALEPH compiler that can run on a variety of
machines (portable) and that can generate code for a variety of
machines (adaptable).
.p1
It is clear that the code generator  of a compiler belongs to
the machine dependent part of that compiler,
provided that all optimizations that can be done machine independently
are not considered as part of the code generator.
In most compilers, however, the code generator is not the
only part that contains machine dependencies.
The first ALEPH compiler, for instance, had this regrettable quality.
In the new version of the ALEPH compiler
all machine dependencies are located in the code generator.
This is necessary
to adapt the ALEPH compiler easily to generate code for a new
machine.
.p1
The machine dependencies should not only be grouped together in one
module, but this module must be easily separable from the rest
of the compiler as well. This implies that
a clear interface between the machine-independent and the machine-dependent
part is another necessity for portability and adaptability.
.p1
The ALEPH compiler consists of the following parts:

.nf
lexical analyzer and parser,
semantic analyzer and machine-independent code generator,
machine-dependent code generator.
.fi

.p1
The lexical scanner and the parser make up the first scan, while the semantic
analyzer  and  the machine-independent code generator form the second scan of the compiler.
These two scans will not have to be changed when the compiler is moved to
another machine. They are written in ALEPH. This is a vital property,
and enables the machine independent part of the compiler to
be moved just as any other machine independent ALEPH program.
The design of the ALEPH compiler will be described
elsewhere.
.p1
The output of the second scan consists of a machine-independent intermediate
code called "ALICE". This code can be thought of as the assembly language
of an abstract machine.
The machine-dependent code generator translates ALICE to machine code and must be rewritten
for every new machine. It must therefore be easy to translate
ALICE to various kinds of machine codes.
The format of ALICE must be simple enough
to be translated by a macro-processor or macro-assembler.
.p1
The ALICE statements must
deliver information to the machine-dependent code generator when the machine-dependent code generator
needs that information, so that ALICE macros can be processed one by one.
Unfortunately, this need varies from implementation
to implementation. ALICE is therefore a rather redundant language.
ALICE programs must be, on the other hand, manageable in size  and
not all the needs for future implementations can be predicted.
It is impossible to supply each bit of information where it
might be needed by an implementation.
Some
trade-offs are made, whether on purpose or not.
.p1
The need for the machine-dependent code generator to be easily separable from
the rest of the compiler lays two obvious requirements on ALICE.
The first one is that
ALICE has to serve as a one-way information carrier from the second scan
to the machine-dependent code generator. The second is that ALICE is the only interface
between the second scan and the machine-dependent code generator.
.p1
These two requirements guarantee that no information about the machine
can be used by the second scan and that the machine-dependent code generator
uses no global data from the rest of the compiler. This ensures that
the translation from ALEPH to ALICE will not introduce machine dependencies
and that an ALICE text can be translated without further reference to the
original ALEPH text.
.p1
These requirements have not been easy to fulfil. The evaluation
of expressions, for instance, must be postponed until machine-dependent code generation,
because some values are machine dependent quantities. This, of course, has
its effect on both ALICE and the first two scans of the compiler.
.p1
The alternative, on the other hand, seems even worse. If information
about the machine and the implementation can flow back from the machine-dependent code generator
to the second scan, the uniqueness of the ALICE translation of an ALEPH
program is lost. For every different target machine a different ALICE
would have been created. This could cause a discouraging feedback
loop between
host machine and target machine.
Furthermore, if the machine-dependent code
generator were to use global data from the rest of the compiler,
it would
become impossible to put ALICE, the interface between them, on a
file and send it to a new machine.





1.2  Porting an ALEPH program to a new machine.
.p2
Suppose that a program written in ALEPH has to be ported to a new
machine which has no ALEPH compiler available.
The program is translated to ALICE and written in a standard
format, on some information carrier such as a magnetic tape.
Together with this program, other software  to make the
bootstrapping as easy as possible, is ported. To pass this stage of the porting
process smoothly, the character set of ALICE is kept to a bare minimum [2].
.p1
To run the ALICE program on the new machine, a translator from ALICE
to machine code and a suitable run-time system have to be constructed
by the installer.
The installer has to make decisions about the evaluation of expressions,
the data-representation, the allocation of tables and stacks, the calling
mechanism and the passing of parameters. These decisions will be
influenced by the architecture of the new machine,
the ALEPH program(s) that have to be run, and the amount of time the
installer has available.
.p1
If the machine is small or the ALEPH programs to be run are going to need large
tables and stacks, the installer may have to provide a means for allocating
tables and stacks on background memory. The installer may decide
to generate very compact code that has to be interpreted by a small driver
which is part of his run-time system, to keep the storage needed for the code as small
as possible.
.p1
The first implementation may be inefficient but easily set up. The installer
can, for instance, decide to use the ALICE to FORTRAN translator written
in FORTRAN, which will be part of the software sent along on the tape.
If he does this, a lot of decisions do not have to be bothered about anymore,
and all that has to be done is getting a big FORTRAN program
running. The code
derived this way will be very inefficient only acceptable in
a first bootstrap.
.p1
The first ALICE-to-machine-code translator may be realized by means of a
macro-processor. This will make the translation easy as long as the
installer does not want fancy optimizing, which requires
reading of a number of ALICE statements together, code motion or other
tricks.
.p1
The T-diagrams below describe the various stages  which
the implementation of an ALEPH compiler on a new machine has to go through.

.nf

.ne 10


       ALEPH   ALICE	     ALEPH   ALICE
	    ->			  ->
	  ALEPH	 ALEPH	 ALICE	ALICE
		      ->
		    CYBER

		    CYBER


.fi


.p1
The translation of the ALEPH compiler on the host machine
to get the
ALICE version of it is sketched above. This ALEPH to ALICE compiler in ALICE
will be sent to the target machine.



.nf
.ne 10
      ALEPH   ALICE	   ALEPH   ALICE
	   ->			->
	 ALICE	ALICE	tmc    tmc
		     ->
		    APR

		    APR
		     T

		     T
.fi


.p2
The above T-diagram exemplifies the translation
of the ALEPH compiler
on the target machine
by an ALICE processor (APR),
to the ALEPH compiler written in target machine code (tmc).
APR might be a macro-processor fed with appropriate
macro-definitions. Together with
a suitable run-time system this will give a first version of the
ALEPH compiler:
.nf


.ne 3
		   ALEPH   ALICE
			->
			T
.fi
.p2
The first version of the ALEPH compiler will generate ALICE. So
for every ALEPH program to be translated to machine code
the ALICE processor is needed:




.nf



.ne 8
	F			F		     F
      ALEPH   ALEPH   ALICE   ALICE   ALICE   tmc   tmc
		   ->			   ->
		   T			   APR

		   T			   APR
					    T

					    T
.fi
.p2
This process can be cut short by changing the machine-independent
code generator of the ALEPH compiler (still generating ALICE)
into a machine-dependent one,
generating tmc.
How this change	 has to be made is shown by the ALICE to tmc
translator, which is already written and tested.
This will give a final version of the ALEPH compiler on the new machine:
.nf


		   ALEPH   tmc
			->
			T
.fi
.bp

2  Outline of ALICE



2.1  ALICE grammars
.p2
In the sequel of this report, context-free rules are used to
describe the format of ALICE statements. The fancy way to
describe the format of these context-free rules is of course by
writing a context-free grammar for them, but let us keep things
simple. The context-free rules consist of a left
hand side terminated by a colon and a right hand side terminated
by a period. The alternatives of a right hand side are separated
by semicolons and the notions making up an
alternative are separated by commas. Notions
consist of letters. Square brackets around a phrase (a piece of an alternative)
are shorthand to
indicate two alternatives: one with the phrase and one without it,
so

a    : b, [c, d], e.

means

a    : b, c, d, e;
       b, e.

.p1
Terminal notions are those ending with "symbol", such as
"end symbol", and the
notions:


"character",
"end of line",
"string",
"integer".
.p1
Terminal notions ending with "symbol" are represented by
three-letter tags.  A string is a sequence of characters
surrounded by quotes; a quote within the string is represented by
a quote-image (two quotes). An integer is an unsigned sequence
of decimal digits.
Comments in the grammar are surrounded by dollar tokens.
.p1
There are two context-free grammars describing ALICE. The
first one is a very simple grammar, which defines ALICE as an
almost unstructured sequence of macros. This grammar does not define the
order in which the macros will occur and the language produced
by this grammar is therefore a superset of ALICE. It still is a
useful description of ALICE because it may serve as a guide for the
writing of a set of macro-definitions for a macro-processor that
is, in most cases, going to be the first translator from ALICE to
target machine code. In other words,
there is a one-to-one correspondence between the macros of the
first grammar and the macro-definitions in the macro-processor
version of the ALICE translator.
.p1
The second grammar is more complicated,	 because  it
describes the structure of ALICE and the order in which the
macros can occur. This grammar is written to define ALICE precisely
and to make the meaning of the various macros understandable.
Together with the other sub-sections of section 3, this grammar
is the ultimate description of ALICE.
.bp
2.2  The format of ALICE macros
.p2
ALICE statements are sometimes called macros in this report, even though processors
other than macro-processors may be used to translate ALICE.
An ALICE statement consists of a macro name possibly followed by a
space and a number of parameters separated by commas.
One macro is written per line, or card or record. The macros are
delimited in a medium dependent way. In the grammar it says that
macros are delimited by 'end of line's, but for every system
this may mean something different.

Examples:


.nf
jmp 15
lab 15
str "Ewige Blumenkraft"
erl gtc
efc 10,gtc,2,0,15
chd 1,a
.fi
.p1
This format has been chosen because it is easily adapted to the format
demanded by most
macro-assemblers.  It is inevitable that some assemblers will
already use macro names of ALICE. Solutions for these problems
must depend on the local circumstances. One could, for instance,
decide to prefix all ALICE macros with some special character or
to change some of the macro names of ALICE by means of an editor.
.p1
General-purpose macro-processors, such as ML/1 and
STAGE2, also find this format easy to digest. In ML/1 [3] a
macro can be used to describe the delimiter structure of the
parameter part of all macros (the macro called "params" in section 2.6).
This macro definition makes the other macro
definitions look less sloppy.
ML/1 does not consider 'end of line' as 'end of macro'.
It is therefore possible to group ALICE macros in one macro
definition in ML/1.
In STAGE2 [4] every macro is supposed to be written on
one line. There is no problem with the
absence of a special 'end of macro' character, since STAGE2
accepts 'end of line' for this.
.p1
The first ALICE-to-pdp11/45-assembly-language translator
was written in ML/1 without problems. This was done while ALICE
was still changing frequently. ML/1 was chosen, first, because it was
available and second, because it is easy to
change the delimiter structures of macro definitions in ML/1.
Once ALICE had been stabilized,
an ALICE-to-assembly-language translator was
written in a high-level language, because large ML/1 programs are
hardly readable, let alone self documenting
and, because ML/1 programs run slowly and demand lots of storage.




.bp
2.3  Features needed to translate ALICE
.p2
It is not enough for the ALICE translator to process
single macros independently,
because some of the macros communicate with each other.
The translator has to keep track of this communication.
In all cases but one, a fixed number of macro-time global variables
(a macro-time variable is a variable of the ALICE translator)
can serve
this purpose.
The exception is the communication between evaluating expressions,
declaring constants and referring to them in executable code.
The feature needed to handle this case, a macro-time symbol table,
will be discussed now.

.p1
Roughly speaking, an ALICE program consists of three parts:
.nf

1: values
2: data
3: rules

.fi
.p1
In the 'values' part all expressions are evaluated and information to
administrate lists and files is gathered. Both expression evaluation
and the gathering of this  information can be
done at macro time (when ALICE is translated)
and therefore no assembly code has to be generated
for it. The ALICE processor has to store the values and use them later on
when macros belonging to the 'data' and 'rules' part are translated.
.p1
The 'data' part declares all constant sources, variables, lists, initial
list contents (called list filling),
and the administration structures for lists and files.
Constant sources are constant actual parameters of calls.
.p1
Example:

Consider the following piece of an ALEPH program:


.nf
'constant' char distance = /1/ - /0/,
	   character 0 = /0/.

'action' print digit + >digit - int - char:
	   times + digit + char distance + int,
	   add + int + character 0 + char,
	   print char + char.


.fi
.p1
In the 'values' part of the ALICE equivalent of this program
the expressions "/1/ - /0/" and "/0/" will be evaluated:

.nf
chd 1,1
chd 2,0
sub 3,1,2

.fi
.bp
.p1
The first two macros are character-denotation macros. They demand
a conversion from character to integer of their second parameter. The value
thus obtained will be referred to by their first parameter. The third macro
demands a subtraction of the two values just obtained, the result of which
will be referred to by its first parameter.
.p1
In the 'data' part two constant sources corresponding to "char distance" and
"letter 0" will be declared.
These constant sources have values calculated in the 'values' part. The first
parameter of these macros stands for the name of the datum, while the second
refers back to values:

.nf
css 1,2
css 2,3

.fi
.p1
In the 'rules' part the ALICE code for the constant actual parameter
of the affix form "times + digit + char distance + int"
will consist of a macro referring back to both
the 'data' macro "css 2,3" and the 'values' macro "sub 3,1,2" involved:

.nf
lvc ---,2,3,---

.fi
.p2
One way to translate these macros is to build up a symbol table
while processing the 'value' macros, to generate assembly-language
data declarations for the 'data' macros, and to refer to these declarations
in the code generated for the 'rules' macros.
In this scheme the 'rules' macros cause no problems because the
parameters give all information that is needed.
How to handle the communication between the 'value' and 'data' macros
will be shown below for both ML/1 and STAGE2.
.p2
In ML/1 dynamically defined macros have to serve for building the symbol table.
Character-to-integer conversion is not a primitive available in ML/1,
so this has to be done by means of macro definitions, such as:
.nf

mcdef chtoint0 as 48
mcdef chtoint1 as 49
.fi

.p2
STAGE2 offers exactly the primitives needed for character
conversion and symbol table manipulation. For the latter the
associative addressing concept of STAGE2 can be used.
.p2
An example of an ML/1 version and a STAGE2 version of the macro-definitions
for the macros with macro-names "chd", "int", "sub" and "css" is given
in section 2.6.
.bp
2.4  The character set
.p2
Suppose a program written in ALEPH, say an ALGOL 68 compiler, has to be
ported to a new machine and that this program
contains all sorts of weird
characters like broken backslashes and so on.
How should this program be ported to the new
machine?
.p1
Not in ALICE but in ALEPH! (section 1.2)
.p1
For one thing, when an ALEPH program is translated
to ALICE it tends to become very big and almost
unreadable for human beings.
So if one can avoid porting programs
in ALICE, one had better avoid it.
.p1
There is one program that must be ported in ALICE:
the ALEPH compiler. Apart from the compiler and
test programs for the ALICE system, all ALEPH programs to
be ported will be ported in ALEPH.
.p1
The first thing to do is to implement the ALEPH
compiler on the new machine. The ALEPH
compiler doesn't contain characters other than
the 'worthy' ALEPH characters and newlines.
The fifty-six worthy ALEPH characters are:

  A to Z
  0 to 9
  space
  + * , . / " ' ( ) [ ] - : ; = < > $ #

.p1
This set of worthy ALEPH characters is a
proper subset of the worthy ALGOL 68 characters [5],
and also a subset of ASCII and EBCDIC.
'end of line' is no worthy character because on some installations
it isn't even a character.
.p1
If ALEPH programs are to be compiled on the new machine
this set of worthy ALEPH characters is the minimal set
needed.
.p1
If the new machine can't provide this minimal set or a
reasonable equivalent, special machine dependent arrangements
are needed, because the ALICE version of the compiler
contains the characters of the minimal set and also, because
some character code has to be chosen for representing the worthy
characters in the ALEPH programs that will have to be compiled in a later stage,
anyway.
These problems are very machine dependent and can only be solved
at the new machine.
.p1
The character set needed for ALICE is identical to the character
set needed for ALEPH.
Therefore the ALICE version of the ALEPH compiler does not give rise
to additional problems as far as the character set is concerned.
.p1
Now let us suppose that the ALEPH compiler has been installed
and the compiler still generates ALICE.
ALICE plays a different role now: it serves as an interface
between two parts of the compiler, running on the same machine.
ALICE might only have survived as a set of calls from the code-generating
routines that have become part of the second scan.
.p1
At this stage the ALGOL 68 compiler, written in ALEPH, can
be ported. If the weird characters
belong to the character set
available on the new machine,
they can be transferred via ALICE in exactly the
same way the worthy ALEPH characters will be transferred. If
they cannot be read in, some escape mechanism has to be designed
for them.
.p1
But this is not a problem on the ALICE level, so
in ALICE we shall not bother about it. It does not help
to distribute the problem of the weird characters over all
phases of the compilation process and it is certainly
impossible to solve this problem for all character sets on
all machines.
.p1
In the sequel we shall assume that the only characters
in ALICE programs that are to be ported to new machines
are the worthy ALEPH characters and that the characters
in the ALICE  interface between two parts of a compiler
on one machine are the characters available on that
machine.
.nf
.bp
2.5  The simple ALICE grammar



$Comments such as this one are surrounded by dollar tokens$



$ALICE terminal symbols		representation	$



$macro names$
add symbol;			$	add	$
begin file adm symbol;		$	bfa	$
call id symbol;			$	cll	$
class begin symbol;		$	csb	$
class end symbol;		$	cse	$
char denotation symbol;		$	chd	$
constant source symbol;		$	css	$
communication symbol;		$	cmm	$
copy a reg symbol;		$	car	$
copy from input gate symbol;	$	cig	$
copy v reg symbol;		$	cvr	$
divide symbol;			$	dvd	$
end file adm symbol;		$	efa	$
end list symbol;		$	els	$
end symbol;			$	end	$
end values symbol;		$	eva	$
exit symbol;			$	ext	$
ext fcall symbol;		$	efc	$
ext scall symbol;		$	esc	$
ext table length symbol;	$	etl	$
ext table decl symbol;		$	etd	$
ext call end symbol;		$	ece	$
ext scall id symbol;		$	esi	$
ext fcall id symbol;		$	efi	$
extension call symbol;		$	etc	$
extension copy symbol;		$	exc	$
extension end symbol;		$	exe	$
extension id symbol;		$	exi	$
ext rule decl symbol;		$	erl	$
fail tail id symbol;		$	fti	$
fallow symbol;			$	flw	$
fcall symbol;			$	fcl	$
class box id symbol;		$	cbi	$
end class box symbol;		$	ebx	$
free w reg symbol;		$	frw	$
indexed input parameter symbol; $	iip	$
indexed output parameter symbol;$	iop	$
input gate symbol;		$	igt	$
int symbol;			$	int	$
int fill symbol;		$	itf	$
jump symbol;			$	jmp	$
label symbol;			$	lab	$
link symbol;			$	lnk	$
list adm symbol;		$	ldm	$
list symbol;			$	lst	$
loada global symbol;		$	lag	$
loada stack var symbol;		$	las	$
loadv constant symbol;		$	lvc	$
loadv limit symbol;		$	lvl	$
loadv list elem symbol;		$	lvi	$
loadv stack var symbol;		$	lvs	$
loadv variable symbol;		$	lvv	$
loadw symbol;			$	ldw	$
manifest constant symbol;	$	mcn	$
multiply symbol;		$	mul	$
rule id symbol;			$	rli	$
numerical symbol;		$	num	$
output gate symbol;		$	ogt	$
pointer symbol;			$	ptr	$
program id symbol;		$	pid	$
restore to output gate symbol;	$	rog	$
root symbol;			$	rut	$
source line symbol;		$	srl	$
scall symbol;			$	scl	$
stack frame symbol;		$	sfr	$
status symbol;			$	sts	$
storew variable symbol;		$	swv	$
storew list element symbol;	$	swi	$
storew stack var symbol;	$	sws	$
string length symbol;		$	sln	$
string fill symbol;		$	str	$
subtract symbol;		$	sub	$
success tail id symbol;		$	sti	$
target stack frame symbol;	$	tsf	$
unstack and return symbol;	$	unr	$
variable symbol;		$	var	$
zone bounds symbol;		$	znb	$
zone value symbol;		$	znv	$

$delimeters$
space symbol;			$	" "	$
comma symbol;			$	 ,	$
end of line;			$medium dependent$

$parameters$
new line symbol;		$	nln	$
same line symbol;		$	sln	$
rest line symbol;		$	rln	$
new page symbol;		$	npg	$
max char symbol;		$	mxc	$
word size symbol;		$	wsz	$
max int symbol;			$	mxi	$
min int symbol;			$	mni	$
int size symbol;		$	isz	$
comma-tag symbol;		$	com	$
space-tag symbol;		$	spc	$
min addr symbol;		$	mna	$
max addr symbol;		$	mxa	$
virt length symbol;		$	vln	$
nil symbol;			$	nil	$
false symbol;			$	fls	$
true symbol;			$	tru	$

add-tag symbol;			$	add	$
subtr symbol;			$	sub	$
mult symbol;			$	mul	$
divrem symbol;			$	div	$
plus symbol;			$	pls	$
minus symbol;			$	min	$
times symbol;			$	tms	$
incr symbol;			$	inc	$
decr symbol;			$	dec	$
less symbol;			$	les	$
lseq symbol;			$	lsq	$
more symbol;			$	mor	$
mreq symbol;			$	mrq	$
equal symbol;			$	eql	$
noteq symbol;			$	ntq	$
random symbol;			$	rnd	$
set random symbol;		$	srn	$
set real random symbol;		$	srr	$
sqrt symbol;			$	sqr	$
pack int symbol;		$	pki	$
unpack int symbol;		$	upi	$
bool invert symbol;		$	biv	$
bool and symbol;		$	bnd	$
bool or symbol;			$	bor	$
bool xor symbol;		$	xor	$
left circ symbol;		$	lci	$
right circ symbol;		$	rci	$
right clear symbol;		$	rcl	$
is elem symbol;			$	isl	$
is true symbol;			$	itr	$
is false symbol;		$	isf	$
set elem symbol;		$	stl	$
clear elem symbol;		$	cll	$
extract bits symbol;		$	exb	$
first true symbol;		$	ftr	$
pack bool symbol;		$	pkb	$
unpack bool symbol;		$	upb	$
to ascii symbol;		$	tsc	$
from ascii symbol;		$	fsc	$
pack string symbol;		$	pks	$
unpack string symbol;		$	ups	$
string elem symbol;		$	ste	$
string length-tag symbol;	$	stl	$
compare string symbol;		$	cms	$
unstack string symbol;		$	uns	$
previous string symbol;		$	pvs	$
was symbol;			$	was	$
next symbol;			$	nxt	$
previous symbol;		$	prv	$
list length symbol;		$	lsl	$
unstack symbol;			$	utk	$
unstack to symbol;		$	ust	$
unqueue symbol;			$	unq	$
scratch symbol;			$	scr	$
get line symbol;		$	gln	$
put line symbol;		$	pln	$
get char symbol;		$	gch	$
put char symbol;		$	pch	$
put string symbol;		$	pst	$
get int symbol;			$	gnt	$
put int symbol;			$	pnt	$
get data symbol;		$	gdt	$
put data symbol;		$	pdt	$
$other primitives used as parameters$
string;				$character sequence
				 delimited by quotes.
				 quotes in the string are represented by
				 quote images ("")  $

character;
integer.			$digit sequence$




ALICE program		: program id symbol, sp, string, el,
						 $title string$

			  status information,

			  values,
			  end values symbol, el,
			  data,

			  communication area, $ends data declarations$

			  rules,

			  end symbol, sp, string, el. $title string$


sp			: space symbol.
co			: comma symbol.
el			: end of line.


status information	: status symbol, sp,
			  integer, co, $maximal stack frame$
			  integer, co, $maximal gate size$
			  integer, co, $number of locations in value table$
			  integer, co, $number of variables$
			  integer, co, $number of files$
			  integer, co, $number of breathing lists$
			  integer, co, $number of non-breathing lists$
			  integer, co, $background:
					0: No lists on background
					1: Lists on background$
			  integer, el. $dump:
					0: no dump
					1: rule dump
					2: global dump
					4: member dump$

values			: value, [values].


value			: int symbol, sp, location, co, integer, el;
			  manifest constant symbol, sp,
			  location, co, manco, el;
			  char denotation symbol, sp, location, co,
			  character, el;
			  string length symbol, sp, location,
			  co, integer, el;
			  ext table length symbol, sp, location,
			  co, string, el;
			  operator, sp, location, co,
			  valref, co, valref, el.

manco			: new line symbol;
			  same line symbol;
			  rest line symbol;
			  new page symbol;
			  max char symbol;
			  word size symbol;
			  max int symbol;
			  min int symbol;
			  int size symbol;
			  comma-tag symbol;
			  space-tag symbol;
			  min addr symbol;
			  max addr symbol;
			  virt length symbol;
			  nil symbol.

operator		: add symbol;
			  subtract symbol;
			  multiply symbol;
			  divide symbol.

location		: integer.
valref			: integer.
repr			: integer.



data			: data item, [data].
data item		: constant source symbol, sp, repr,
			  co, valref, el;
			  list symbol, sp, repr, co, list type, co,
			  valref, el;
			  end list symbol, sp, repr, co,
			  list type, co, valref, el;
			  int fill symbol, sp, valref, el;
			  string fill symbol, sp, string, el;
			  fallow symbol, sp, valref, el;
			  variable symbol, sp, repr, co, valref, co,
			  repr, co, string, el;
			  begin file adm symbol, sp, file info, el;
			  end file adm symbol, sp, file info, el;
			  numerical symbol, sp, valref, co, valref, el;
			  pointer symbol, sp, repr, el;
			  list adm symbol, sp, list info, el;
			  ext table decl symbol, sp,
			  list info, co, string, el.

list info		: repr, co, integer, co, valref, co,
			  valref, co, valref, co, valref, co,
			  valref, co, repr, co, string.


file info		  repr, co, integer, co, integer, co,
			  repr, co, string, el.


communication area	: communication symbol, sp,
			  repr, co, repr, co, repr, co, string, el,
			  status information.

rules			: rule, [rules];
			  call, [rules];
			  primitive, [rules];
			  parameter, [rules].


rule			: ext rule decl symbol, sp, repr, co, extag, el;
			  root symbol, sp, string, el;
			  rule id symbol, sp, repr, co, integer, co,
			  integer, co, string, el;
			  stack frame symbol, sp, integer,
			  co, integer, el;
			  success tail id symbol, sp, repr, co,
			  integer, co, integer, el;
			  output gate symbol, sp, integer, el;
			  unstack and return symbol, sp,
			  integer, co, integer, co, return type, el;
			  fail tail id symbol, sp, repr, co,
			  integer, co, integer, el;
			  copy from input gate symbol, sp, formal, el;
			  restore to output gate symbol, sp, formal, el.


return type		: true symbol;
			  false symbol.


extag			: add-tag symbol;
			  subtr symbol;
			  mult symbol;
			  divrem symbol;
			  plus symbol;
			  minus symbol;
			  times symbol;
			  incr symbol;
			  decr symbol;
			  less symbol;
			  lseq symbol;
			  more symbol;
			  mreq symbol;
			  equal symbol;
			  noteq symbol;
			  random symbol;
			  set random symbol;
			  set real random symbol;
			  sqrt symbol;
			  pack int symbol;
			  unpack int symbol;
			  bool invert symbol;
			  bool and symbol;
			  bool or symbol;
			  bool xor symbol;
			  left circ symbol;
			  right circ symbol;
			  right clear symbol;
			  is elem symbol;
			  is true symbol;
			  is false symbol;
			  set elem symbol;
			  clear elem symbol;
			  extract bits symbol;
			  first true symbol;
			  pack bool symbol;
			  unpack bool symbol;
			  to ascii symbol;
			  from ascii symbol;
			  pack string symbol;
			  unpack string symbol;
			  string elem symbol;
			  string length-tag symbol;
			  compare string symbol;
			  unstack string symbol;
			  previous string symbol;
			  was symbol;
			  next symbol;
			  previous symbol;
			  list length symbol;
			  unstack symbol;
			  unstack to symbol;
			  unqueue symbol;
			  scratch symbol;
			  get line symbol;
			  put line symbol;
			  get char symbol;
			  put char symbol;
			  put string symbol;
			  get int symbol;
			  put int symbol;
			  get data symbol;
			  put data symbol.



call			: call id symbol, sp, repr, co, integer, el;
			  input gate symbol, sp, integer, el;
			  target stack frame symbol, sp, integer, co,
			  integer, el;
			  scall symbol, sp, repr, el;
			  fcall symbol, sp, repr, co, repr, el;
			  link symbol, sp, repr, el;
			  ext scall id symbol, sp, repr, co, extag, el;
			  ext fcall id symbol, sp,
			  repr, co, extag, co, repr, el;
			  ext scall symbol, sp, repr, co, stag, el;
			  ext fcall symbol, sp,
			  repr, co, extag, co, repr, el;
			  ext call end symbol, co, repr, el.



primitive		: jump symbol, sp, repr, el;
			  source line symbol, sp, integer, el;
			  class box id symbol, el;
			  class box end symbol, sp, repr, el;
			  class begin symbol, sp, repr, co,
			  optimize, el;
			  class end symbol, sp, optimize, el;
			  zone bounds symbol, sp,
			  minbound, co, maxbound, co, repr, el;
			  zone value symbol, sp, repr, co, valref, co,
			  repr, el;
			  extension id symbol, el;
			  extension call symbol, el;
			  extension copy symbol, sp, formal, el;
			  extension end symbol, sp, repr, el;
			  exit symbol, sp, repr, co, valref, el;
			  label symbol, sp, repr, el.


minbound		: repr, co, valref.
maxbound		: repr, co, valref.
optimize		: true symbol;
			  false symbol.



parameter		: copy v reg symbol, sp, formal, el;
			  copy a reg symbol, sp, formal, el;
			  loadv constant symbol, sp,
			  repr, co, valref, el;
			  loadv variable symbol, sp, repr, el;
			  indexed input parameter symbol, el;
			  loadv list elem symbol, sp, integer, el;
			  loadv limit symbol, sp, integer, el;
			  loadv stack var symbol, sp, integer, el;
			  loada global symbol, sp, repr, el;
			  loada stack var symbol, sp, integer, el;
			  loadw symbol, sp, formal, el;
			  storew variable symbol, sp, repr, el;
			  indexed output parameter symbol, el;
			  storew list element symbol, sp, select, el;
			  storew stack var symbol, sp, integer, el;
			  free w reg symbol, el.
.fi
.bp
2.6  Example: ML/1 and STAGE2 symbol table usage
.p2
In this example the macro-definitions for the macros with macro names
"chd", "int", "sub" and "css"
(which need a symbol table to communicate with each other)
are given in both ML/1 and STAGE2.
In the ML/1 version,
a special macro "eval(	 )" is needed to evaluate pieces of text
which are not a parameter of a macro call.


.nf
mcins !.
mcskip mt,[]
mcdef params
as [n1 opt , n1 or nl all]
mcdef chtint0 as 48
mcdef chtint1 as 49
mcdef chd params
as [mcdefg sym!a1. as chtint!a2.
]
mcdef int params
as [mcdefg sym!a1. as !a2.
]
mcdef sub params
as [mcset t1 = eval( sym!a2. ) - eval( sym!a3. )
mcdefg sym!a1. as !t1.
]
mcdef eval with ( )
as [mcdef temp as !a1.
temp]
mcdef css params
as [c!a1.: eval( sym!a2. )
]



.fi
.p1
If we feed ML/1 with these macro definitions and the following
ALICE macros:
.nf


chd 1,1
chd 2,0
sub 3,1,2
css 1,2
css 2,3


we get the following result:



c1: 48
c2: 1

.fi
.p2
The STAGE2 version of the same macro definitions is:


.nf
.li 1
.$$'0 (+-*/)
end $.
'f0$
$
$ .
'10$
$
chd $,$.
under x'10 store '28$
$
sub $,$,$.
under x'10 store eval x'20-x'30$
$
int $,$.
under x'10 store '20$
$
under $ store $.
'f3$
$
under $ store eval $.
under '10 store '24$
$
css $,$.
xcss '10,x'20$
$
xcss $,$.
c'10: '21$
$$



.fi
.p1
To prevent STAGE2 from giving an IOCH message, it has to be halted
explicitly, for instance by means of the ALICE end macro.
When running STAGE2 with these macro definitions and the macros:



.nf
chd 1,1
chd 2,0
sub 3,1,2
css 1,2
css 2,3
end "program name"


.fi
STAGE2 gives the same result as ML/1 above.

.bp
3  Description of the various constructs of ALICE



3.1  Values
.p2
The only primitive data types in ALEPH are integer
and string. Expressions can assume only constant integral values. So
one could expect that
at the stage of ALICE generation, all expressions have been shrunken to
values and that, for example, in ALICE a constant
will be declared as follows:

con <representation of the constant>, <value of the constant>

.p1
However, at a closer inspection of constant declarations in ALEPH
one comes upon machine dependent constructions such as:

'constant' two power 32 = 256 * 256 * 256 * 256.

'constant' cap = /A/ - /a/.

'constant' middle = (>>table - <<table) / 2.

'table' messages = ("MEDIUM" : mclw).


.p1
All four constants declared above (two power 32, cap, middle,
mclw), illustrate a different kind of problem for a machine
independent ALEPH compiler.
These problems are:

1  The range of integer values;

2  The character code;

3  The division of the address space into virtual address spaces;
   [ALEPH MAN 4.1.4]

4  The number of machine words occupied by a string of a  certain
   length.

.p2
ALICE provides the possibility for
all expressions to be evaluated at
macro time, for the obvious reason that most programs are
more often executed than compiled.
ALICE would have been simpler if the expressions were
evaluated at run time. But then the ALEPH compiler would be
inefficient and would generate inefficient code.



.bp
3.1.1  The range of integer values.
.p2
The host and target environments each have ranges of integer values
that they can handle. Such a range depends on the word size of the
machine and on the number of words the installer decides to allocate
for an integer.
These ranges can influence the evaluation
of expressions.
.p1
One scheme for expression evaluation is:

Do as much calculation as possible on the host machine.
When the host machine can no longer handle the value of the
expression because of machine dependencies, send the intermediate
results to the target machine.
On the target machine the final evaluation has to be done.
.p1
This is unnecessarily complicated.
.p1
Because the host machine cannot do the complete evaluation
of the expressions,
no calculation at all
will be done at the host machine.
The range of integer values of the host machine no longer plays
a role. All integral denotations
are handled on the host machine as
strings of digits that have to be sent to the target
machine.
.p1
The ALICE processor on the target machine must be able to
evaluate the expressions. To this end a very simple expression
language has been added to ALICE.
By means of this expression language the four problems
mentioned above, can be solved.

Syntax:

.nf
values			: value, [values].

value			: value definition;
			  calculation.

value definition	: int denotation;
			  manifest constant;
			  char denotation;
			  string length;
			  ext table length.

int denotation		: int symbol, sp,
			  location, co, integer, el.

calculation		: operator, sp, location, co,
			  valref, co, valref, el.

operator		: add symbol;
			  subtract symbol;
			  multiply symbol;
			  divide symbol.

location		: integer.
valref			: integer.

.fi
.bp
Semantics:

value table:
.p1
The ALICE processor
has a table in which it can store
the values represented by value-definition macros
and calculation macros.
The values in this value table will not be redefined.
The location parameter of a value macro indicates
where to put a value in this table.
The location parameters form an ascending
row of integers. They are the indices in the value table.
A result needed for further calculation
is referred to by means of a valref parameter in one
of the operand fields of a calculation macro.
The value table is only needed at macro time.


int denotation:
.p1
The sequence of decimal digits is converted to an integer value.
This value is stored in the value table at the location referred to
by the location parameter.


calculation:
.p1
The result of the operation on the values referred to by the two valrefs
is stored in the value table at the location referred to by the location
parameter.
.p0
The operators add, subtract and multiply do what one would
expect. The divide operator conforms to the
ALEPH division. The result of an integer division n = p / q
(q =/ 0) is a value n such that p >_ (n * q) and (p - n * q)
is as small as possible.
.br
So, 7 / 3 = 2, 7 / (-3) = -2,
(-7) / 3 = -3, (-7) / (-3) = 3 .



Example: ALICE for calculation of the value of two power 32:

.nf
int 1,256
mul 2,1,1
mul 3,2,2
.fi
.p2
The degree of optimizing done by the ALICE generator
has
not quite been decided yet.
Somebody, in this case the author, did a beautiful job of optimizing
here and it is not sure whether the compiler will go this far.
.p1
After these macros have been processed, the ALICE processor
has either stored the value 4294867296 in its table at location 3,
or it has emitted an error message.
If the value is stored in the table, it can be used throughout the
further code generation, for example as a literal in a constant source.
.p1
It is not required that the ALICE processor evaluate these expression
macros at compile time. It could also let the assembler do the job
or even generate code to evaluate the expressions at the start of the
execution of the program. The location parameter can be used to create a name.


3.1.2  The character code.
.p2
One way to get rid of the problem of the character code is
to demand a specific internal character code, such as ASCII, inside
every ALEPH program and consequently inside
the ALEPH compiler. The standard externals 'getchar' and 'putchar'
can perform a
conversion between the installation character code and
the internal character code.
This gives the compiler the opportunity to calculate with character
codes machine independently.
.p1
This at first sight attractive idea has two
drawbacks. It becomes hard to read characters efficiently
when they have to be handled one by one. This argument becomes
important if one wants to read lines efficiently.
The problem has not even completely vanished, because there
will always be installations with non-ASCII characters available.
.p1
The character code will therefore be chosen by
the installer and character denotations
are handed over to the target machine via ALICE by means of character denotation macros.

Syntax:

.nf
char denotation		: char denotation symbol, sp, location,
			  co, character, el.

.fi
Semantics:
.p1
The result of the conversion from character to character code is stored
in the value table at the location referred to by the location parameter.


.p1
Special care has to be taken for characters, such as comma and space.
They can make the recognition of parameters difficult for the ALICE processor,
since they mix up with the delimiter structure of the macros.
Therefore these characters will be declared
in manifest constant macros.
Manifest constant macros are used as an escape out of these
exceptions, and to declare machine dependent constants.

Syntax:

.nf
manifest constant	: manifest constant symbol, sp,
			  location, co, manco, el.

manco			: new line symbol;
			  same line symbol;
			  rest line symbol;
			  new page symbol;
			  max char symbol;
			  word size symbol;
			  max int symbol;
			  min int symbol;
			  int size symbol;
			  comma-tag symbol;
			  space-tag symbol;
			  min addr symbol;
			  max addr symbol;
			  virt length symbol;
			  nil symbol.

.fi
Semantics:
.p1
The value denoted by the manco parameter is stored in the value table
at the location referred to by the location parameter.



Example: ALICE code to calculate the value of cap:

chd 4,A
.br
chd 5,a
.br
sub 6,4,5




3.1.3  The address space
.p2
The data types in an ALEPH program are integer, string,
and lists of these. The storage unit containing an integer is called a
"virtual machine word". A virtual machine word is mapped on an (implementation
dependent) number of machine words.
.p1
ALEPH programs assume the  existence of a "virtual address space"
for each list declared. Items in a list are identified by
unique addresses, which are represented by integral values. These integral
values are called "virtual addresses" and are
the elements of the virtual address space
associated with the list.
A virtual address identifies one virtual machine word.
The virtual address spaces of all lists
form the "address space".
.p1
The ALEPH programmer can influence the distribution of the virtual address
spaces over the address space by means of size estimates.
But he cannot influence the range of
integers available for the address space. This can only be done by the
installer of ALICE.
.p1
Because virtual addresses are represented by integers,
the range of integer values must be a superset of the address
space.
The size of the address space appears to be the most important
measure for the range of integer values in
an implementation.
.p1
The association
of virtual addresses with lists is done by the compiler and it must
be done in such a way that every list gets enough virtual addresses
associated with it,
that is, at least as many virtual addresses as it will ever have items.
It is of course impossible to predict the needs of a list
because the amount of virtual
addresses needed for a list depends on
the dynamic behaviour of the program.
To help the compiler in making a reasonable guess, the ALEPH programmer
writes "size estimates" in the declaration of his lists.
.p1
The virtual address space
of a list consists of
a contiguous set of integers.
The address space consists of a contiguous
set of integers, too.
Because the virtual address spaces of the lists form a partition of
the address space,
a virtual address uniquely identifies a
list and it may identify an item of that list. The question whether a virtual
address points into a certain list can easily be answered by checking
whether the virtual address lies between the min limit and the max limit
of the list.
.p1
For stacks with an absolute size estimate and tables
it is known at compile time
how many virtual addresses they need.
Stacks with a relative size estimate
get a virtual address space proportional to their size estimate.
The bounds of the address space can be declared in ALICE
by means of manifest constants (min addr, max addr).
.p1
The ALEPH external table does not fit into
this scheme, because the size of an external table
can only be derived by inspection of the machine-dependent
string that defines its contents. This
must be done by the ALICE processor when
an external table length macro is encountered.

Syntax:

.nf
ext table length	: ext table length symbol, sp, location,
			  co, string, el.


.fi
Semantics:
.p1
The string is an exact copy of the string written in the
ALEPH external table declaration.
The number of virtual machine words occupied by the external table
is derived by inspection of the string. The value thus obtained
is stored in the value table at the location referred to by the location parameter.




.p1
It is clear that programs containing external table declarations
are far from portable. The ALEPH compiler itself will therefore not
contain external table declarations.



3.1.4  Strings
.p2
The way strings are handled varies from installation to
installation, so it is clumsy to make strict assumptions
about the way characters are packed into machine words.
To define a manifest constant giving the number
of characters fitting in a machine word
is to assume too much about the way strings are allocated,
because the number of words
occupied by a string is not always the quotient of the string
length and that constant.


.p1
It
is, on the other hand, impossible to make no assumptions at all
about the allocation of strings, for one thing because
the allocation of a string influences the range of virtual addresses
needed for the list the string belongs to.
It is assumed that all strings of a certain length
occupy the same number of words, no matter which
characters they contain or how strings are allocated.
This assumption can bother an installer
but it has to be made, because
of the dependence of address calculation and string length mentioned
earlier.
The value of mclw (in the example in section 3.1)
can be calculated as the sum of the min limit
of the table messages and the number of words occupied by the string
"MEDIUM".

Syntax:

.nf
string length		: string length symbol, sp,
			  location, co, integer, el.
.fi



Semantics:
.p1
The number of virtual machine words occupied by a string containing
a number of characters specified by the second parameter is derived.
This value is stored in the value table at the location referred to by
the location parameter.



.bp
3.1.5  Example


Suppose the following list declarations occur in an ALEPH program:
.nf


'table' powers = ( "one" :one,
		   "ten" :ten,
		   "hundred" :hundred,
		   "thousand" :thousand
		 ).

'stack' [= 5 =] digits,
	[ 30 ]	anonymous operands,
	[ 50 ]	rationals.

The information characterizing a list consists of:

.nf
its min limit,		( :< )
its left pointer,	( << )
its calibre,		( <> )
its right pointer,	( >> )
its max limit.		( >: )


.fi
The following value macros may be generated to divide the
address space and to gather other necessary information.

xxx this is a comment macro to be ignored by the ALICE processor

.nf
mcn 1,mna
xxx :<powers = mna

int 3,1
xxx <>powers = 1

add 2,1,3
xxx <<powers = :<powers + <>powers

stl 25,3
xxx string length("one")

add 21,1,25
xxx one = :<powers + string length("one")

stl 26,3
xxx string length("ten")

add 22,21,26
xxx ten = one + string length("ten")

stl 27,7
xxx string length("hundred")

add 23,22,27
xxx hundred = ten + string length("hundred")

stl 28,8
xxx string length("thousand")

add 24,23,28
xxx thousand = hundred + string length("thousand")

xxx >>powers = thousand
xxx >:powers = thousand
xxx :<digits = thousand
xxx >>digits = thousand

int 8,1
xxx <>digits = 1

add 7,24,8
xxx <<digits = :<digits + <>digits

int 29,5
xxx length(digits)

add 10,24,29
xxx >:digits = :<digits + length(digits)

xxx :<anonymous operands = >:digits
xxx >>anonymous operands = >:digits

int 13,1
xxx <>anonymous operands = 1

add 12,10,13
xxx <<anonymous operands
xxx	= :<anonymous operands + <>anonymous operands

mcn 35,mxa
xxx max addr

sub 36,35,10
xxx virtual left over = max addr - >:digits

int 37,0
xxx initialize sum relative size estimates

int 30,30
xxx relative size estimate anonymous operands

add 38,37,30
xxx sum = sum + relative size anonymous operands

int 32,50
xxx relative size estimate rationals

add 39,38,32
xxx sum = sum + relative size rationals
xxx last calculation for sum

dvd 31,36,39
xxx unit virtual addresses =
xxx		 virtual left over / sum size estimates

mul 41,31,30
xxx virtual size anonymous operands
xxx	= size estimate * unit virtual addresses

add 15,10,41
xxx >:anonymous operands
xxx	= :<anonymous operands + virtual size anonymous operands

xxx :<rationals = >:anonymous operands
xxx >>rationals = >:anonymous operands


int 18,1
xxx <>rationals

add 17,15,18
xxx <<rationals = :<rationals + <>rationals

xxx >>rationals = mxa
xxx end of ALICE macros


RESULT:

	powers	digits	anonymous	rationals
			operands

:<	1	24	10		15
<<	2	7	12		17
<>	3	8	13		18
>>	24	24	10		15
>:	24	10	15		35





one		21
ten		22
hundred		23
thousand	24


.fi
The entries in these tables indicate the location of the various values.

.bp
3.2  Data
.p2
After the values have been calculated, the data initialized
with these values can be declared. ALICE contains the following
data declarations:

.nf
3.2.1	  Integer
3.2.1.1	   Constant source
3.2.1.2	   Variable

3.2.2	  List
3.2.2.1	   List area
3.2.2.1.1   List fillings
3.2.2.2	   List administration
3.2.2.3	   External table

3.2.3	  File
3.2.3.1	  File administration


.fi

Syntax:

.nf
data			: [constant sources],
			  [variable decls],
			  [lists],
			  [files].

lists			: list areas,
			  [ext table decls],
			  list administrations.

files			: file administrations.

.fi

.p0
For all sorts of objects in an ALICE program,
such as data objects, a unique translation-time representation
is needed for reference purposes. This representation ("repr" in the
grammar) is an unsigned integer. Representations can serve the ALICE
processor in various ways. It is easy to make
unique names (labels) from them and they serve at macro time for communication
between macros.
One set of integers is used to give representations to
both data objects and objects in the rules part.

3.2.1  Integer

3.2.1.1	 Constant source
.p2
The values calculated in the values part of the ALICE program are
used for various purposes. Some are intermediate results and are
no longer of interest in the data and rules part. Some are used
in list and file administrations and in variable declarations. Others
are used to declare constant sources.

Syntax:

.nf
constant sources	: constant source, [constant sources].

constant source		: constant source symbol, sp, repr, co, valref, el.


constant source		: constant source symbol, sp, repr,
			  co, valref, el.

repr			: integer.

valref			: integer.


.fi
.bp
Semantics:
.p1
A constant source declares a constant actual parameter
of a call, before it is going to be used as such in the rules
part of ALICE.
The value of the constant source is in the value table at the location
referred to by the valref parameter.



Installation hints:
.p1
Depending on the implementation and the facilities the assembler has
to offer, the ALICE processor may act in various ways:

hint 1.
.p0
If the implementation views constant sources just as variables that
happen not to change their value,
the ALICE processor will generate assembly data
declarations from the constant sources.
The representation will then serve to generate a unique label for the
constant. When code for picking up the constant actual parameter has to
be generated, this can be done easily because the ALICE macro for doing
this contains the representation of the constant source again.

hint 2.
.p0
If the assembler offers a suitable literal mechanism, no code need
be generated from the constant source macros. When the code to pick up
the constant actual parameter is generated, the valref also supplied
in the macro for doing this will serve to refer to the value in the
value table. From this value a literal can be generated.

hint 3.
.p0
In most cases the assembler provides a literal mechanism for numbers
up to a certain maximum value, for instance because both opcode and literal
have to fit in one machine word. A mixture of 1. and 2. will then
do the job.

.bp
Example:
.nf

ALEPH: 0 -> counter

ALICE			macro time action

values part

int 5,0			hint 1. and 2.
			store value 0 in symbol table at location 5

data part

css 21,5		hint  1.
			generate label from representation
			get value from symbol table location 5
			generate data declaration

			hint 2.
			do nothing

rules part

lvc 21,5		hint 1.
			use repr to refer to data declaration

			hint 2.
			get value from symbol table at location 5
			use value to generate a literal
.bp
.fi
3.2.1.2	 Variable
.p2
From a variable macro the
ALICE processor will generate an assembler data declaration.
The value used to initializing
the variable has been calculated in the values part.
.br

Syntax:


.nf
variable decls		: variable decl, [variable decls].

variable decl		: variable symbol, sp, repr, co,
			  valref, co, repr, co, string, el.


.fi
Semantics:
.p1
A variable declaration causes the allocation of one virtual
machine word represented by the first parameter and initialized
with the value in the value table at the location referred to by the second parameter.
The third parameter is the representation of the next variable to be
declared. The fourth parameter contains the ALEPH variable-tag
in string quotes.
If the third parameter is equal
to zero, there is no next variable declaration.



Installation hints:
.p1
The first parameter will be used to generate a label, the second
to generate a data declaration.
If a global dump is requested (see section 3.4	status macro),
the third parameter serves to generate a pointer to the next variable
and the fourth parameter serves to generate a string containing the
ALEPH variable-tag.



Example:

ALEPH:
'variable' counter = 0.

ALICE			macro time action

values part

int 5,0			store value 0 in value table
			at location 5


.bp
data part

var 39,5,40,"counter"	generate label from representation 39
			get value from symbol table location 5
			and generate data declaration
			if global dump is requested generate
			pointer to next variable and
			string with the name of this variable


.fi


3.2.2  List

3.2.2.1	 List area
.p2
The list areas are used to set up the physical address space
in which the lists are floating, and to initialize these lists
with their initial list filling.
For each ALEPH list a list area will be declared giving
the initial fillings consisting of integer values already calculated
in the values part, or of strings.
Information about the list type and the size of the virtual address
space is supplied at the beginning and end of the area.
A list is called "breathing" if its size can change at run time, that is
if it is a stack with a relative size estimate.
When and how the physical address space is actually set up depends on
the implementation.



Syntax:

.nf
list areas		: list area,
			  [list areas].


list area		: list symbol, sp, repr, co,
			  list type, co,
			  valref, el,
			  [list fillings],
			  end list symbol, sp, repr, co,
			  list type, co, valref, el.

list type		: integer.

list fillings		: list filling, [list fillings].

list filling		: int fill symbol, sp, valref, el;

			  string fill symbol, sp, string, el;

			  fallow symbol, sp, valref, el.

.fi


.bp
Semantics:
.p1
The parameters of the first macro of a list area, a list macro, have the following
meaning:

First parameter, repr: the representation of the list.

Second parameter, list type: an integer
.nf
	0:	not breathing, no background
	1:	not breathing,	  background
	2:	    breathing, no background
	3:	    breathing,	  background
.fi
.p1
If background is specified there is a background pragmat identifying the list
in the ALEPH program.
.p1
An int fill macro causes the allocation of a virtual machine word,
initialized with the value in the value table at the location referred to
by the valref parameter.
.p1
A string fill macro causes the allocation of a number of virtual machine
words, initialized with a string value denoted by the string parameter.
.p1
A fallow macro causes the allocation of a number of uninitialized virtual
machine words. This number is found in the value table at the location referred to
by the valref parameter.
.p1
The three parameters of the last macro of a list area, an end list macro, have the
same meaning as those of a list macro.


Installation hints:
.p1
Depending on the target machine, the operating system, and the rest
of the ALICE implementation, the physical address space can be
implemented in various ways:

hint 1.
.p0
Allocate a contiguous chunk of storage for the lists. Put all initial list fillings
of the lists right behind each other in the chunk of storage. Let a run-time routine
shuffle the lists.

hint 2.
.p0
Allocate one chunk of storage as in hint 1.
A non breathing list gets a piece of that chunk just fitting its needs, while a breathing
list gets a number of extra uninitialized storage locations. This can be either a constant
number or a number proportional to the number of virtual addresses  associated with the list.
The list shuffling is done by the same run-time routine as in hint 1.

.bp
hint 3.
.p0
Implement  a paging scheme for the lists. Every list gets one (or more) page(s) in core;
while a complete virtual address space is allocated on disk.

hint 4.
.p0
If the operating system provides a suitable virtual addressing mechanism, map the
virtual ALEPH addresses on the virtual machine addresses. In this case the physical
address space  is equal to the virtual address space.

hint 5.
.p0
How  to deal with the background information depends heavily on the implementation.
It is formally correct to ignore it completely.
If, for instance,
the physical address space is implemented according to hint 3, the background
information has no meaning.
Only in cases where lists can both be allocated in core and on background, the
background information could be of use.


hint 6.
.p0
Most implementers will have to deal with machines having a
von Neumann store, whether they like it or not. In that case
all lists will probably be allocated in one contiguous physical address space.
A list-shuffling routine is then needed as part of the run-time system
to prevent the breathing lists from bumping into
each other.
Because this problem is very likely to arise  for a lot of machines,
such a list-shuffling routine is available in ALEPH (and consequently
in ALICE).


3.2.2.2	 List administration
.p2
A list administration macro is used to generate the administration
information of a list.
The correspondence between a virtual address and a physical address
must be derived from this information, no matter how the lists
are allocated. The limits must be available
in the administration, because they can be used
as actual parameters
at run time. The type, the limits and the maximal virtual address
are inspected when a list is extended. The limits are updated
when the size of the list is changed.

Syntax:

.nf

list administrations	: list administration, [list administrations].

list administration	: list adm symbol, sp,
			  list info, el.

list info		: repr, co, list type, co,
			  valref, co,
			  valref, co,
			  valref, co,
			  valref, co,
			  valref, co,
			  repr, co,
			  string.
.fi



Semantics:
.p1
The first parameter of a list administration is the representation
of the list.
.p1
A list administration macro causes the allocation of a data structure
called "list administration"
such that at least the following information can be kept in it:

The list type, specified by the list type parameter. This parameter has
the same meaning as the list type parameter of a list macro.

The lowest virtual address associated with the list: called "virtual min limit".
This value is found in the value table at the position referred to by the
third parameter.

The highest virtual address associated with the list: called "virtual max limit".
This value is found in the value table at the position referred to by the
fourth parameter.

The virtual address of the left most block in the list: called "virtual left".
This value is found in the value table at the position referred to by the
fifth parameter.

The virtual address of the right most block in the
list: called "virtual right".
This value is found in the
value
table at the position
referred to by the
sixth parameter.

The calibre of the list, that is: the number of elements in one block of the list.
This value is found in the value table at the position referred to by the
seventh parameter.

Information to convert a virtual address associated with the list to the
corresponding physical address.

The address of the next list administration. The eighth parameter contains
the representation of the next list administration or zero.

The ALEPH list-tag. The ninth parameter contains the ALEPH list-tag in
string quotes.

Installation hints:

hint 1.
.p0
The representation of the list can be used to
generate a label of the list administration,
and to make
the address of the list area (same representation)
available in the list administration.


hint 2.
.p0
The ALEPH list-tag is needed for the implementation of data files (see
installation hints of file administration).

.bp
hint 3.
.p0
In most implementations not the whole virtual address space is mapped in
core. In those cases in comes handy to have two extra limits, for instance
called "bumpmin" and "bumpmax", in the list administration, indicating
which portion of the virtual space of the list is mapped in core. If,
for instance, an implementation according to hint 3. in section 3.2.2.1
is chosen, bumpmin and bumpmax are the virtual addresses of the
beginning and end of the core page.


Example:
.p1
Suppose the lists are allocated in one chunk of contiguous storage.
A list is labeled: l<repr of list>
.br
That means: the virtual machine word following the virtual machine word
labeled l<repr> is the left most element of the left most block of the
(initial) list. The virtual address of the left most block of a list
is the virtual left of the list. To convert a virtual address
to a physical address, the mixed expression:

	l<repr> - virtual left + calibre

is added to that virtual address. This mixed expression is also kept
in the list administration.


3.2.2.3	 External table
.p2
An external table is declared by one macro, very
much alike a list administration macro. The external table
macro has one more parameter: the ALEPH string containing
information about the filling of the table. What, exactly, is
in the string depends on the particular implementation and
cannot be described machine independently. It could be a number
of data declarations in assembly language, or an external reference
to be satisfied by the local loader, or an access routine. The ALICE
processor must generate an administration, whose layout
does not differ from the administration of a normal table, because
external tables and tables can both be passed as actual parameters
to the same formal table parameter.

Syntax:

.nf
ext table decls		: ext table decl, [ext table decls].

ext table decl		: ext table decl symbol, sp,
			  list info, co,
			  string, el.
.fi

Semantics:
.p1
An external table macro causes the allocation of a list administration
and a list area. The first nine parameters (list info), have the same
meaning as the parameters of a list administration macro.
The last parameter is an exact copy of the ALEPH string of the external
table.
From this parameter a list area must be generated.


.bp
Installation hints:

.p0
A portable ALICE program, such as the ALEPH compiler, will not contain
external table declarations. The implementation of this macro is therefore
not needed.


3.2.3  File


3.2.3.1	 File administration
.p2
A file administration macro serves to generate book keeping information
and buffers for a file.
The file
administrations are chained, just like the list administrations, so
that they can be easily initialized
or post processed.

Syntax:

.nf
file administrations	: file administration,
			  [file administrations].

file administration	: begin file adm symbol, sp, file info, el,
			  [pointer area],
			  [numerical area],
			  end file adm symbol, sp, file info, el.

file info		: repr, co,
			  file type, co,
			  repr, co,
			  string.

file type		: integer.


numerical area		: numerical symbol, sp,
			  valref, co,
			  valref, el,
			  [numerical area].

pointer area		: pointer symbol, sp, repr, el,
			  [pointer area].

.fi
.bp
Semantics:
.p1
The parameters of the first macro of a file administration, a begin
file administration macro, have the following meaning:

First parameter, repr: the representation of the file.

Second parameter, file type: an integer
	0: scratch charfile
	1: scratch datafile
	2: input charfile
	3: input datafile
	4: output charfile
	5: output datafile
	6: input/output charfile
	7: input/output datafile


If input is specified, the only permitted action is reading.
.br
If output is specified, the only permitted action is writing.
.br
If input/output is specified, both reading and writing are permitted.
.br
If scratch is specified, the file is an input/output file which will
not be available after the execution of the program.


If charfile is specified, the items to be read or written are characters,
represented by (small) integers according to the character code chosen
by the installer.

If datafile is specified, the items to be read or written consist of an
integer value and an indication about its meaning. This indication is
either "numerical" in which case the integer value stands for itself, or
it is the ALEPH name of a list in which case the integer value is an offset
from the left of the list.

Third parameter, repr: the representation of the next file administration
or zero.

Fourth parameter, string: the ALEPH string from the file declaration.



.p1
Pointer macros and numerical macros specify a number of "zone"s.
A zone is a contiguous set of integers.
.br
A numerical macro specifies a zone by supplying two valrefs. The first
valref refers to the minimum of the zone, while the second refers to
the maximum of the zone.
.br
A pointer macro specifies a zone by supplying the representation of a list.
The zone is the virtual address space of the list.

When a file is used for reading, each item delivered will belong in
one of the zones.

When a file is used for writing, each item offered must belong in one
of the zones.

If the file type specifies charfile, there will be no pointer macros.



The parameters of the last macro of a file administration, an end file
administration macro, have the same meaning as those of a begin file
administration macro.


Installation hints:

hint 1.
.p0
If the operating system provides a way to handle character files efficiently,
for instance by packing a number of characters in one word, this facility
can be used for the implementation of charfiles.

hint 2.
.p0
The data item of a datafile can be implemented in two ways.
.br
a) The data item
can consist of an integer value and a Boolean value indicating
that the integer must be considered as a virtual address.
In that case the file will begin with
heading information consisting of triples:
.br
.nf

file name	virtual min limit	virtual max limit.

.fi




b) The data item can consist of two integer values. The first integer
value is a stripped virtual address, that is a virtual address
minus the min limit of the list	 it pointed in. The second integer
indicates in which list the virtual address pointed. Here the the file
will begin with heading information consisting of file names.
.p1
When a data item is read, the following actions have to be performed:

.in 6
1.  Find out whether the data item is a pointer (The Boolean is ____true or
the second integer is positive) or not.

2.  If it is a pointer, identify the list name.
.br
In the first case this is done by comparing the virtual address
with the virtual min limits and max limits of the heading information.
In the second case it is done by selecting the right file name	from the
heading information.

3.  Find the identical list name in the list administrations.
.br
If the list name from the file
is not identical to one of the list names in the program,
the situation is erroneous.

4.  Relocate the pointer.
.br
In the first case this is done by subtracting the old virtual
min limit available in the file heading and adding the
virtual min limit of the identified list.
In the second case this is done by adding the
virtual min limit of the identified list.
.in 0


.bp


