          IDENT  ALFTEXT
          STEXT

************************************************************************
* GENERAL
 SIGNBIT  =      59
 INTSIZE  =      15
 WORDSIZE =      60
 EOILEVEL =      16          'RECORD LEVEL' FOR END-OF-INFORMATION

* CRASH ADDRESSES:
 BADREGS  =      1S17+1      B1 AND/OR B2 HAVE BEEN MESSED UP
 BADFET   =      1S17+2      FET ADDRESS BAD
 BADSEMA  =      1S17+3      SEMAFORE UNDERFLOW
 BADEXTND =      1S17+4      ERROR IN REDIV
 BADSTACK =      1S17+5      STACK OVERFLOW IN REDIV

************************************************************************
*
* THERE ARE TWO TYPES OF DATAFILES, SIMPLE DATAFILES AND MIXED
* DATAFILES. IF THE OPEN ROUTINES FIND THAT THERE ARE ONLY NUMERICAL
* ZONES IN THE AREA, THE FILE IS DESIGNATED 'SIMPLE'.
*
* A SIMPLE DATA FILE CONTAINS THE INTEGERS THAT ARE WRITTEN ON IT
* AS ARE, IN SEQUENTIAL ORDER, WITH NO FURTHER INFORMATION ADDED.
*
* MIXED FILES START WITH A SEQUENCE OF LIST NAMES. THESE LIST NAMES
* ARE IN THE ORDER AS IN THE FILE AREA. EACH NAME IS WRITTEN
* BACKWARDS WORDWISE SO THAT THE FIRST WORD READ ALREADY GIVES
* INFORMATION ABOUT THE LENGTH OF THE LIST NAME.
* THE LIST OF NAMES IS TERMINATED BY A WORD 0.
*
* ONE WORD IS WRITTEN FOR EACH POINTER PASSED TO PUT DATA.
* THE WORD HAS THE FOLLOWING FORMAT:
* BITS 59-48:  4000B, I.E., NEGATIVE FLOATING POINT UNDEFINED
* BITS 47-42:  00B FOR POINTERS, 77B FOR MARKERS
* BITS 41-24:  THE NUMBER OF THE LIST NAME IN THE FILE PREFIX
* BITS 23- 0:  THE OFFSET IN THIS LIST
*
* ONE OR TWO WORDS ARE WRITTEN FOR EACH INTEGER PASSED TO PUT DATA.
* IF THE INTEGER LOOKS LIKE A POINTER, I.E., BITS 59-48 ARE 4000B,
* IT IS PRECEDED BY A MARKER, I.E., A POINTER OF WHICH BITS 47-42
* ARE 77B, OTHERWISE THE INTEGER IS WRITTEN AS IS.
*
 POINTER  =      1           FOR DATA FILES
 NUMERIC  =      0           FOR DATA FILES

************************************************************************
* COMMUNICATION AREA. IT IS PROVIDED BY THE PROGRAM; ITS ADDRESS IS IN:
 CA.ADDR  =      77B         ANSI-FLAG OF FORTRAN, ALSO GOOD FOR ALEPH
* ITS CONTENTS ARE:
 CA.ENTRY =      0           ENTRY-POINT
 CA.FILES =      1           FILE CHAIN ADDRESS, ZERO IF NO FILES
 CA.LIST  =      2           LIST CHAIN ADDRESS, ZERO IF NO LISTS
 CA.DUMP  =      3           DUMP ROUTINE ADDRESS, ZERO IF NOT WANTED
 CA.DPAR  =      4           PARAMETER FOR DUMP ROUTINE
 CA.TEMP  =      5           BEGINNING OF TEMPORARY PARAMETER STORAGE
 CA.SUBP  =      23          PROVISIONAL POSITION OF LINK TO SUBPROGRAMS

 CA.MIN   =      0
 CA.MAX   =      5

************************************************************************
* LIST ADM TABLE, OFFSET FOR SELECTORS: 0 TO N
 []NAME   =      -10         LAST WORD OF NAME OF LIST
 []HIST   =      -9          HISTORY OF STACK,
                             ZERO INDICATES TABLE OR FIXED STACK
 []AIM    =      -8          USED DURING TRANSPORT
 []LSR    =      -7          LAST SOFT RIGHT
 []LINK   =      -6          LINK TO NEXT LIST
* THE FOLLOWING VALUES MAY NOT BE CHANGED SINCE THEY ARE IMPLEMENTED
* THROUGH B-REGISTERS.
 <>       =      -5          SIZE
 <<       =      -4          RELATIVE
 >>       =      -3          RELATIVE
 <<PRE    =      -2          << - <>, I.E., LEFT-MOST ADDR NOT IN LIST
 >>MAX    =      -1          HIGHEST VALUE OF >>, MAY BE RAISED BY
                             REALLOTMENT.

************************************************************************
* FILE ADM TABLE, FET IS LOCATED FROM 0 TO 4
*
 FILE.BGN =      -6          FIRST WORD OF FILE ADM PROPER
 FILE.LST =      -6          POINTER TO FIRST LIST ZONE BLOCK
 FILE.NUM =      -5          POINTER TO FIRST NUMERICAL ZONE BLOCK
*
* FILE AREAS ARE USED FOR DATA FILES. THE ZONES IN THE FILE DECLARATION
* ARE TRANSLATED INTO A SEQUENCE OF BLOCKS OF TWO WORDS EACH,
* ONE FOR EACH ZONE. ALL LIST ZONES PRECEDE ALL NUMERICAL ZONES.
* THE LAST NUMERICAL ZONE BLOCK PRECEDES THE FIRST WORD OF THE FILE
* ADM PROPER, I.E., 'FILE.BGN'.
*
* SEE 'LISTSPNT', 'NUMZNPNT' AND 'EOZNSPNT'.
*
* LIST ZONE BLOCKS:
* THE FIRST WORD CONTAINS THE ADDRESS OF THE LIST ADM IN 17 - 0.
* THE SECOND WORD WILL CONTAIN THE <<PRE OF THE LIST AT OPEN TIME.
*
* NUMERICAL ZONE BLOCKS:
* THE FIRST WORD CONTAINS THE LOWER BOUND OR 40...0B IF IT IS MISSING
* THE SECOND WORD CONTAINS THE UPPER BOUND OR 37...7B IF IT IS MISSING
*
 FILETYPE =      -4          CONTAINING:
 INPBIT   =      0           SET FOR INPUT FILE
 OUTPBIT  =      1           SET FOR OUTPUT FILE
 CHDATBIT =      2           SET FOR DATA-FILES
 CIBIT    =      3           SET IF FILE CONTAINS CONTROL INTEGERS
 READBIT  =      4           SET FOR FILES PRESENTLY USED FOR READING
 SIMPBIT  =      5           SET FOR SIMPLE DATA FILES
*
 FILECHN  =      -3          FILE INDICATOR AND CHAIN
*
 FILECH#  =      -2          NUMBER OF BITS TO THE RIGHT OF THE LAST
                             CHARACTER USED IN WORD, OR:
 BLSTAT   =      -11         A 00B IN POSITIONS 5-0 HAS JUST BEEN MET
                             WHICH NECESSITATED A LOOK-AHEAD FOR EOL
 NEWSTAT  =      -10         FRESH RECORD
 NCISTAT  =      -9          CONTROL INT HAS JUST BEEN CREATED
 CISTAT   =      -8          CONTROL INT HAS JUST BEEN EXTRACTED
 EORSTAT  =      -7          END-OF-RECORD HAS JUST BEEN PROCESSED,
                             LEVEL IS PACKED AS EXPONENT.
 LST      MIN    BLSTAT,NEWSTAT,NCISTAT,CISTAT,EORSTAT
 LASTSTAT =      LST
*
 FILEWORD =      -1          WORD UNDER OPERATION

************************************************************************
* CHARACTER CONSTANTS, FOR DISPLAY CODE
 NEWLINE  =      -1R
 SAMELINE =      -1R+
 NEWPAGE  =      -1R1
 RESTLINE =      -63

************************************************************************
* BITS IN THE REACT=-WORD. REACT= IS PRE-SET BY THE SYSTEM; IT CAN
* BE CHANGED BY ENTERING THE
* PROGRAM BY A RJ, WITH THE NEW BITS IN X1.
 PARAMBIT =      0           SET IF CC-PARAMETERS TO BE EXAMINED
 ERMSBIT  =      3           SET IF ERROR MESSAGE TO BE PRODUCED
 EXMSBIT  =      4           SET IF EXIT MESSAGE TO BE PRODUCED
 CMUSEBIT =      6           SET IF MEMORY USAGE TO BE REPORTED
 DUMPBIT  =      9           SET IF DUMP ROUTINES ARE TO BE CALLED
 RETRNBIT =      12          SET IF NO RETURN ADDRESS IS AVAILABLE

                             ***** SYSTEM ROUTINE MACROS *****

 BX=      MACRO  HARD,NAME   FOR THE (SOMETIMES INEVITABLE) INTERFACE
* BETWEEN NAMED REGISTERS (X.NAME) AND HARD-DESIGNED REGISTERS (X.HARD).
* THE ASSUMPTION IS THAT 'HARD' EQUALS 'NAME'. IN CASE OF FAILURE A
* WARNING IS GIVEN AND CODE 'BX.HARD X.NAME' IS GENERATED.
          IFNE   HARD,NAME,2
 2        ERR    HARD - NAME MISMATCH
          BX.HARD X.NAME
 BX=      ENDM

 CLOSECPU MACRO
* MOVES THE CPU TO THE STATE 'CLOSE-DOWN'.
          SX6    10001B      BITS 12 AND  0
          LX6    47D         BITS 59 AND 47
 +        SA5    =XCPUSEMA
          BX6    -X6*X5
          SA6 A5 CPUSEMA
 CLOSECPU ENDM

 DOWNCPU  MACRO
* MOVES THE CPU 1 PROTECTION LEVEL DEEPER DOWN.
          MX6    1
          LX6    48D-59D     BIT 48
 +        SA5    =XCPUSEMA
          IX6    X5+X6
          SA6 A5 CPUSEMA
 DOWNCPU  ENDM

 ENDCPU   MACRO
* DEACTIVATES THE PROTECTION MECHANISM; IF AN INTERRUPT OCCURRED
* CONTROL IS RETURNED TO THE SYSTEM RECOVER ROUTINE TO SERVICE
* FURTHER CANDIDATES.
          RECOVR =XCPUSEMA+1,0B CLEAR REQUEST
          SA5    =XCPUSEMA
          AX5    18D
          SX5    X5          BITS 35-18
          NZ,X5  =XCPUSEMA+1
 ENDCPU   ENDM

 EOZNSPNT MACRO  N           BRINGS THE FILE AREA END OF ZONES
*                            POINTER TO REG X.N, ASSUMING
*                            X1 CONTAINS THE ADDRESS OF THE FILE
          SX.N   X1+FILE.BGN
 EOZNSPNT ENDM

 ERROR    MACRO  TEXT,DESCR
* D=DECIMAL, N=7-CHAR NAME, L=LIST-ADDRESS, F=FILE-ADDRESS, C=OCTAL
          ERROR\ ERROR,(TEXT),(DESCR)
 ERROR    ENDM

 ERREXT   MACRO  TEXT,DESCR
* D=DECIMAL, N=7-CHAR NAME, L=LIST-ADDRESS, F=FILE-ADDRESS, C=OCTAL
          ERROR\ ERREXT,(TEXT),(DESCR)
 ERREXT   ENDM

 ERROR\   MACRO  ROUT,TEXT,DESCR
          LOCAL  FORM
 M        MICRO  1,,\_TEXT_\
 FORM     MICCNT M
          IFGT   FORM,40,1
          ERR    MESSAGE TOO LONG
 BITS     MICRO
          IRP    DESCR
 M        MICRO  1,1, DESCR
 FORM     SET    -1
          IFC    EQ, D "M" ,1
 FORM     SET    10B
          IFC    EQ, N "M" ,1
 FORM     SET    20B
          IFC    EQ, L "M" ,1
 FORM     SET    30B
          IFC    EQ, F "M" ,1
 FORM     SET    40B
          IFC    EQ, C "M" ,1
 FORM     SET    50B
          IFEQ   FORM,-1,1
          ERR    BAD DESCRIPTOR DESCR
 M        MICRO  2,1, DESCR
          IFC    EQ, "M" . ,1
 M        MICRO  3,, DESCR
          IFLT   "M",0,1
          ERR    BAD DESCRIPTOR DESCR
          IFGT   "M",7,1
          ERR    BAD DESCRIPTOR DESCR
 M        OCTMIC FORM+"M",2
          IFEQ   "M",0,1
          ERR    BAD DESCRIPTOR DESCR
 BITS     MICRO  1,, "BITS""M"
          IRP
 BITS     MICRO  1,10, "BITS"0000000000
 +        RJ     =X_ROUT_
 -        VFD    30D/"BITS"B
          DIS    ,\_TEXT_\
 ERROR\   ENDM

 EXTEND12 MACRO              X1: ADDRESS OF STACK, X2: LENGTH.
                             WILL NOT CHANGE X1.
          RJ     =XEXTEND=
 EXTEND12 ENDM

 GETCHAR  MACRO  EOR         FILE ADDRESS ALREADY IN X1
          RJ     =XGET1HAR
          NZ,X0  EOR
 GETCHAR  ENDM

 IFCINT   MACRO  REG,LAB TO LAB IF REG IS CONTROL INT
          NG     REG,LAB
 IFCINT   ENDM

 IFNOT    MACRO  R1,R2,LAB   R1 (X-REG EXCEPT 4,5) CONTAINS ADDRESS OF
*                            LIST-VECTOR, R2 (ID.) CONTAINS POINTER INTO
*                            THAT LIST. IF NOT CONSISTENT, A JUMP
*                            TO LAB FOLLOWS.
          SA5    R1+>>
          SA4    A5+B1       <<PRE
          IX4    X4-R2       MUST BE NEGATIVE
          IX5    X5-R2       MUST BE POSITIVE
          BX4    -X4+X5
          NG,X4  LAB         OTHERWISE OUT.
 IFNOT    ENDM

 ISNOTPNT MACRO  XN,LABEL    JUMP TO LABEL IF XN IS NOT POINTER
          PL,XN  LABEL
          IR,XN  LABEL
 ISNOTPNT ENDM

 LISTSPNT MACRO  N           BRINGS THE FILE AREA LISTS POINTER
*                            TO REG X.N, ASSUMING X1 CONTAINS
*                            THE ADDRESS OF THE FILE
          SA.N   X1+FILE.LST
 LISTSPNT ENDM

 MUSTBE   MACRO  R1,R2,MSG   IF R2 NOT IN R1, ERROR 'MSG'
          LOCAL  ERROR
          IFNOT  R1,R2,ERROR
          RMT
 M1       MICRO  2,, R1
 M2       MICRO  2,, R2
 ERROR    ERREXT (MSG),(L"M1",D"M2")
          RMT
 MUSTBE   ENDM

 NONDIG   MACRO  XIN,NODIG,XRES IF XIN NOT DIG THEN GOTO NODIG
                                ELSE XRES:= VALUE OF DIG
          S_XRES XIN-1R0-10
          PL     XRES,NODIG  MORE THAN '9'
          S_XRES XRES+10     VALUE
          NG     XRES,NODIG
 NONDIG   ENDM

 NUMZNPNT MACRO  N           BRINGS THE FILE AREA NUMERICAL ZONES
*                            POINTER TO REG X.N, ASSUMING
*                            X1 CONTAINS THE ADDRESS OF THE FILE
          SA.N   X1+FILE.NUM
 NUMZNPNT ENDM

 OVFL     MACRO  VAL,SCR     TESTS 'VAL' FOR PROPER INTEGER, USES 'SCR'.
                             IF 'SCR' IS MISSING, X5 IS USED.
                             SRC:= VAL * 0
 M        MICRO  1,, SCR
          IFC    EQ, SCR  ,1
 M        MICRO  1,, X5
          IFC    NE, VAL "M" ,1
          B"M"   VAL
          A"M"   48
          NZ,"M" =XOVFL
 OVFL     ENDM

 PROTCPU  MACRO
* STARTS THE PROTECTION MECHANISM AND PUTS THE CPU IN THE STATE
* 'INITIALIZING'. SHOULD BE THE VERY FIRST THING SINCE IT RUINS
* ALL REGISTERS.
          SX6    4001B       BITS 11 AND 0
          LX6    47D         BITS 58 AND 47
          SA6    =XCPUSEMA
          RECOVR =XCPUSEMA+1,14B     LIMIT AND OPERATOR-ABORT
 PROTCPU  ENDM

 RUNCPU   MACRO
* BRINGS CPU IN STATE 'RUNNING'
          MX6    1
          LX6    46D-59D     BIT 46
 +        SA5    =XCPUSEMA
          BX6    X5+X6
          SA6 A5 CPUSEMA
 RUNCPU   ENDM

 SINGLE   MACRO  INSTR       ASSEMBLES THE INSTRUCTIONS IN 'INSTR'
* INTO A SINGLE (UNINTERRUPTIBLE) MACHINE WORD. THE INSTRUCTIONS ARE
* SEPARATED BY \-S, AND MAY NOT CONTAIN $-S.
          LOCAL  IC,L
          BSS    0           FORCE UPPER
 IC       =      *
 M        MICRO  2,,$_INSTR_\$
 OP       DUP    -1
 L        MICCNT M
 .1       IFEQ   L,0
          STOPDUP
 .1       ELSE
 L        SET    1
 CHAR     DUP    -1
 C        MICRO  L,1,$"M"$
 .2       IFC    EQ,$"C"$\$
          STOPDUP
 .2       ELSE
 L        SET    L+1
 .2       ENDIF
 CHAR     ENDD               L POINTS AT FIRST \
 C        MICRO  1,L-1,$"M"$ FIRST INSTRUCTION
 M        MICRO  L+1,,$"M"$    REST INSTRUCTIONS
        "C"
 .1       ENDIF
 OP       ENDD
*
          IFNE   IC,*,3      IF IC /= * AND
          IFEQ   IC+1,*,1    ( IC  /= *-1 OR
          IFNE   *P,60,1     *P /= 60) THEN
          ERR    INSTRUCTIONS NOT SINGLE
 SINGLE   ENDM

 STARTPR  MACRO  SYSIDF      ANNOUNCES START OF SYSTEM PROCESS SYSIDF
          SX5    SYSIDF*10000B+1B
          LX5    -12
          RJ     =XANN.TIM
 STARTPR  ENDM

 STOPPR   MACRO  SYSIDF      ANNOUNCES STOP OF SYSTEM PROCESS SYSIDF
          SX5    SYSIDF*10000B+2001B
          LX5    -12
          RJ     =XANN.TIM
 STOPPR   ENDM

 UPCPU    MACRO
* MOVES THE CPU 1 PROTECTION LEVEL UP; MAY CALL 'CPUTRAP'.
          MX6    1
          LX6    48D-59D     BIT 48
 +        SA5    =XCPUSEMA
          IX6    X5-X6
          SA6 A5 CPUSEMA
 +        DF,X6  *+1         IF UNDEFINED (6000B OR 1777B)
          RJ     =XCPUTR.P   CALL TRAP.
 UPCPU    ENDM

*
          END
LIBRARY(ALFLIB,OLD)
REPLACE(*,LGO)
FINISH.
ENDRUN.
