*                                   ************************************
          SPACE  10,10
 
 
 
 
 
 
                             ***** SYSTEM SUBROUTINES *****
 
          IDENT  ALFSYS
          SST
 LOADSP   =      10100B      ROOM REQUIRED BY THE LOADER FOR LOADING 
                             A PROGRAM IN SCOPE 3.4.4
          SPACE  10,10
* DUMP RUN-TIME INFO                ************************************
 DUMP     JP     *+1S17      PRINTS COLLECTED RUN-TIME INFORMATION
 
          STOPPR 1           THE PROGRAM ITSELF
          RJ     =XCLO.TIM   CLOSE TIMING FILE IF PRESENT
 
          SA5    REACT=      REACTION WORD
          LX5    SIGNBIT-CMUSEBIT
          PL,X5  NOCMUSE
* DUMP MAXIMUM STORAGE REQUIREMENTS
          RJ     MSBEGIN
          SX1    =Z/MAX CM USED /
          RJ     MSTEXT
          SA1    RA.LWP      LOADER POINTER
          SA2    =XSTACK<<   END OF PROGRAM
          SX1    X1+77B
          SX2    X2+LOADSP+77B
          MX3    -6          FOR TRUNCATING
          IX4    X1-X2
          AX4    60          SIGN OF DIFFERENCE
          BX1    -X4*X1      ZERO IF X1-X2 < 0
          BX2    X4*X2       ZERO IF X1-X2 >= 0
          BX1    X1+X2       MAXIMUM
          BX1    X1*X3       TRUNCATE TO N00B
          RJ     MSOCT
          RJ     MSEND
 NOCMUSE  BSS    0 
*
          SA5    REACT=      REACTION WORD
          LX5    SIGNBIT-DUMPBIT
          PL,X5  NODUMP
 
          SA5    CA.ADDR     COMMUNICATION AREA
          SA5    X5+CA.DUMP
          ZR,X5  DUMP        NO DUMP ROUTINE
          SB5    X5
          SX7    DUMP        FAKED
          JP     B5          ALEPH-CALL
 NODUMP   BSS    0 
          EQ     DUMP
          SPACE  10,10
* ENDALL                            ************************************
 ENDALL   BSS    0           END PROGRAM, RETURN CODE IN X1
          QUAL   ENDALL
          BX6    X1          SAVE
          SA6    RC               RETURN CODE
          CLOSECPU 
          RJ     DUMP
          RJ     =XCLOFLS
          ENDCPU             TO END CPU PROTECTION
 
          SB3    REGB3       FOR DEBUGGING, POINT TO SAVE AREA
          SA1    RC          PICK UP RETURN CODE 
*
* IF RETRNBIT THEN RETURN
* ELIF X1 = 0 THEN ENDRUN
* ELIF X1 >= -1 THEN ABORT
* ELSE ABORT(NODUMP)
* FI
          SA5    REACT=      REACTION WORD
          LX5    SIGNBIT-RETRNBIT
          NG,X5  NORETRN
*
          SA5    CA.ADDR
          SA5    X5+CA.ENTRY ENTRY POINT ADDRESS 
          SA5    X5          RETURN ADDRESS
          LX5    30
          SB5    X5          ADDRESS SEC
          JP     B5          RETURN TO CALLER
*****************************
 
 NORETRN  BSS    0 
          ZR,X1  ENDRUN
          MX5    -1          -1
          IX5    X1-X5       X1+1
          NG,X5  ABORTS
          ABORT
*****************************
 
 ABORTS   ABORT  ,NODUMP
*****************************
 
 ENDRUN   ENDRUN
*****************************
 
 RC       BSS    1           RETURN CODE
          QUAL * ENDALL
          SPACE  10,10
* ERROR                             ************************************
* ERREXT                            ************************************
          ENTRY  ERROR
 ERROR    JP     *+1S17      THE RJ WILL WRITE HERE THE ADDRESS OF
 -        VFD    30/1        THE CALL AND CLEAR THIS 1
 
          ENTRY  ERREXT
 ERREXT   JP     *+1 NOT S17.THE RJ WILL WRITE HERE THE ADDRESS OF
 -        VFD    30/1        THE CALL AND CLEAR THIS 1
          QUAL   ERROR
 
* DUMP REGISTERS
          RMT
* THE REGISTERS BEING DUMPED WILL BE  OVERLAID OVER THE ROUTINE PARAMS
*REGXA    BSS    16          X0, A0, X1, A1, ... X7, A7
*REGB3    BSS    5           B3, B4, ... B7
 REGXA    =      PARAMS
 REGB3    =      REGXA+16
          RMT
*DUREGS   JP     *+1S17      RJ ENTRY
          SB1    B1-1
          NZ     B1,BADREGS  SOMEBODY MESSED UP THE SYSTEM 
          SB2    B2-2
          NZ     B2,BADREGS  SOMEBODY MESSED UP THE SYSTEM 
          SB2    2           RESTORE
          SB1    A6
          SA6    REGXA+2*6
          BX6    X0
          SA6    REGXA
          BX6    X1
          SA6    A6+B2
          BX6    X2
          SA6    A6+B2
          BX6    X3
          SA6    A6+B2
          BX6    X4
          SA6    A6+B2
          BX6    X5
          SA6    A6+B2
          BX6    X7
          SA6    REGXA+2*7
          SX6    A0
          SA6    REGXA+1
          SX6    A1
          SA6    A6+B2
          SX6    A2
          SA6    A6+B2
          SX6    A3
          SA6    A6+B2
          SX6    A4
          SA6    A6+B2
          SX6    A5
          SA6    A6+B2
          SX6    B1
          SA6    A6+B2
          SX6    A7
          SA6    A6+B2
          SB1    1           RESTORE
* B-REGS 
          SX6    B3
          SA6    REGB3
          SX6    B4
          SA6    A6+B1
          SX6    B5
          SA6    A6+B1
          SX6    B6
          SA6    A6+B1
          SX6    B7
          SA6    A6+B1
*         EQ     DUREGS
 
          CLOSECPU 
 
          SA3    EXIT        ENTERED THROUGH EXIT?
          SA4    REACT=      REACTION WORD
          BX5    X4          COPY
          LX3    SIGNBIT     CLEAR IF EXIT
          LX4    SIGNBIT-ERMSBIT
          LX5    SIGNBIT-EXMSBIT
          BX4    X3*X4       - EXIT AND ERMSBIT
          BX5    -X3*X5      EXIT AND EXMSBIT
          BX3    X4+X5       EITHER CONDITION SUFFICES
          PL,X3  NOERRMSG
 
 
*MEMNUMB  JP     *+1S17      DISPLAYS MESSAGE WITH A0 VALUE
          SA1    REGXA+1     A0 VALUE
          ZR,X1  NOMEMNB
          RJ     MSBEGIN
          AX1    16D         LEVEL NUMBER IN 17-16
          ZR,X1  NOLEVEL
          SX1    =Z/AT LEVEL /
          RJ     MSTEXT
          SA1    REGXA+1     A0 VALUE
          AX1    16D         LEVEL NUMBER IN 17-16
          SX1    X1+1R0      TURN INTO DISPLAY CODE
          RJ     MSCHAR
          SX1    1R          SPACE
          RJ     MSCHAR
 NOLEVEL  BSS    0 
          SX1    =Z/AT LINE NUMBER /
          RJ     MSTEXT
          SA1    REGXA+1     A0 VALUE
          MX2    -16D
          BX1    -X2*X1      LINE NUMBER IN 15-0 
          RJ     MSINT       MEMBER NUMBER
          RJ     MSEND
 NOMEMNB  BSS    0 
*         EQ     MEMNUMB
 
          SA1    ERROR       MAY BE RETURN JUMP
          BX2    X1
          LX2    -1          GET BIT 0 
          PL,X2  ERROR1      WAS RETURN JUMP
* ERREXT PART:
          MESSAGE (=C/ERROR IN ALEPH EXTERNAL/),LOCAL,R
          SA1    ERREXT      RETURN ADDRESS
* END OF ERREXT PART
* BACK JUMP IN X1
 ERROR1   BSS    0 
          LX1    30
          SA1    X1-1        GET RJ + BITS
          MX6    30
          BX6    -X6*X1      BITS ONLY 
          LX6    30
          SA6    =SBITS      SAVE
*
          SX5    A1+B1       ADDRESS OF MESSAGE
          MESSAGE X5,LOCAL,R 
*
 REGS     BSS    0 
* 'BITS' CONTAINS GROUPS OF 6 BITS, STARTING FROM BIT 59, EACH GROUP 
* DESRIBING HOW TO DISPLAY THE CONTENTS OF A GIVEN X-REG. A GROUP
* 00B TERMINATES THE SEQUENCE.
* BITS 2-0 IN A GROUP DESIGNATE THE X-REG, BITS 5-3 INDICATE A
* DISPLAY MODE (D, N, L, F AND C ARE 1 ... 5 RESP.)
          RJ     MSBEGIN     START MESSAGE BUFFER
          SA2    BITS
          LX2    6           POSITION NEXT GROUP 
          SX1    X2          ISOLATE IT
          BX6    X2-X1       REMOVE IT FROM ORIGINAL
          SA6 A2 BITS
          ZR,X1  ENDREGS     END OF INFO
 
* BIT 5-3: DISPLAY MODE, BIT 2-0 REGISTER NUMBER.
          MX2    -3
          BX2    -X2*X1      REG #
          LX2    1           BECAUSE OF INTERVENING A-REGS.
          SA5    REGXA+X2    REGISTER
          BX6    X5                   SAVED
          SA6    =SREG                      IN 'REG'
          AX1    3           DISPLAY MODE
          SB5    X1
*
          SB4    B5-B1
          SB5    B4-B1
          ZR,B4  INT         FOR D
          ZR,B5  TAG         FOR N
          SB4    B5-B1
          SB5    B4-B1
          ZR,B4  LIST        FOR L
          ZR,B5  FILE        FOR F
          EQ     OCT         FOR C AND NONSENSE
 
 INT      BSS    0 
          SA1    REG         REREAD THE REGISTER 
          BX3    X1
          AX3    48
          NZ,X3  OVERFL      IF INTEGER TOO BIG
          RJ     MSINT
          EQ     DISPL
 
 TAG      BSS    0 
          SA1    REG         REREAD THE REGISTER 
          RJ     MSTAG
          EQ     DISPL
 
 LIST     BSS    0 
          SX1    =Z/LIST= /
          RJ     MSTEXT
          SA1    REG         REREAD THE REGISTER 
          SX1    X1+[]NAME   ADDRESS OF LIST NAME
          RJ     MSALFSTR
          RJ     MSEND
          RJ     MSBEGIN
          SX1    =Z/ MIN= /
          RJ     MSTEXT
          SA1    REG         REREAD THE REGISTER 
          SA1    X1+<<
          RJ     MSINT
          RJ     MSEND
          RJ     MSBEGIN
          SX1    =Z/ MAX= /
          RJ     MSTEXT
          SA1    REG         REREAD THE REGISTER 
          SA1    X1+>>
          RJ     MSINT
          EQ     DISPL
 
 FILE     BSS    0 
          SX1    =Z/FILE= /
          RJ     MSTEXT
          SA1    REG         REREAD THE REGISTER 
          SA1    X1          FILE NAME + BITS
          RJ     MSTAG
 
          SA1    REG         REREAD THE REGISTER 
          SA3    X1+FILETYPE TO GET THE READ-BIT 
          SX4    =Z/, WHILE READING/
          SX5    =Z/, WHILE WRITING/
          LX3    SIGNBIT-READBIT
          AX3    60          -0 IF READING, +0 IF WRITING
          BX4    X3*X4
          BX5    -X3*X5
          BX1    X4+X5       CORRECT TEXT ADDRESS
          RJ     MSTEXT
          EQ     DISPL
 
 OVERFL   SX1    1R*
          RJ     MSCHAR
 OCT      BSS    0 
          SA1    REG         REREAD THE REGISTER 
          RJ     MSOCT
*         EQ     DISPL
 
 DISPL    RJ     MSEND
          EQ     REGS
 
 ENDREGS  BSS    0 
 
 NOERRMSG BSS    0 
* X1:= IF EXITED THEN OLD X1 ELSE -1 FI
          SA1    EXIT
          LX1    SIGNBIT     CLEAR IF EXITED
          AX1    60          +/-0
          SA2    REGXA+2     OLD X1
          SX3    -B1         STANDARD ERROR CODE 
          BX2    -X1*X2      IF EXITED 
          BX3    X1*X3       IF NOT
          BX1    X2+X3       RETURN CODE
 
          EQ     ENDALL
          QUAL * ERROR
 
 REACT=   CON    -0          ALL BITS ON
          SPACE  10,10
* EXIT                              ************************************
          ENTRY  EXIT
 EXIT     JP     *+1S17      THIS LOCATION WILL BE CHANGED BY A RJ EXIT.
 -        VFD    30/1        IT IS CHECKED BY 'ERROR' TO FIND THE MODE
                             OF THE ERROR.
          SX1    B5                ****** OLD CODE *********************
          ZR,X1  ENDALL
          ERROR (EXIT WITH VALUE),D1
          SPACE  10,10
* INITIALIZE MACHINE                ************************************
          ENTRY  INMACH
 INMACH   JP     *+1S17      RJ ENTRY
          BX6    X1          REACT WORD, EITHER FROM CALL OR FROM ENTRY
          SA6    REACT=
          SX6    X2          STORE
          SA6    CA.ADDR     COMMUNICATION ADDRESS
          MX7    0 
          SA7    =XFLS.OK    FILES NOT YET OK
          PROTCPU            START CPU PROTECTION
          SB1    1           B-REG CONSTANTS
          SB2    B1+B1
          SB3    B2+B1
          SA4    RA.LWP
          SB6    X4          STACK POINTER
          SA0    0           MEMBER NUMBER NOT YET SET
*
* LINK POSSIBLE SUBPROGRAMS
          RJ     LINKSUBS
* INIT DUMPER IF PRESENT
          STARTPR 1          THE PROGRAM ITSELF
          SA5    CA.ADDR
          SA5    X5+CA.DUMP  DUMPER ADDRESS, ZERO IF NO DUMPER
          ZR,X5  NODUMPER
          SX6    REGXA       REGISTER DUMPING AREA
          SA6    A5-CA.DUMP+CA.DPAR DUMPER PARAMETER
 NODUMPER BSS    0 
* CONTROL-CARD PARAMETERS
          SA5    REACT=      REACTION WORD
          LX5    SIGNBIT-PARAMBIT
          PL,X5  NOPARAMS
          RJ     PARAMS
 NOPARAMS BSS    0 
*
          RJ     =XINITEXT   INITIALIZE FLOATING LIST ADMINISTRATION 
* OPEN FILES
          RJ     =XOPFLS
          MX7    1 
          SA7    =XFLS.OK    FILES OK
*
          RUNCPU
          EQ     INMACH
          SPACE  10,10
* INTEGER TO CHARACTER              ************************************
*INT.CHR  JP     *+1S17      CONVERTS THE 48-BIT INTEGER IN X2
          ENTRY  INT.CHR
          BSS    1           -4, DIGITS, RIGHT-ALIGNED, 4 BITS / DIGIT
          BSS    1           -3, SHIFT THAT WILL RIGHT-ALIGN NEXT CHAR
          BSS    1           -2, SIGN, DISPLAY CODE
          BSS    1           -1, - NUMBER OF LEADING SPACES
 INT.CHR  JP     *+1S17      CONVERTS THE 48-BIT INTEGER IN X2 TO
*                            DECIMAL. THE RESULT IS DESCRIBED ABOVE. 
*
          BX5    X2
          AX5    48
          NZ,X5  =XOVFL
* CORRECT X2, SIGN IN X5:
* SIGN
          MX6    -1
          BX6    -X6*X5      0 FOR +, 1 FOR -
          SX6    X6+1R+      SIGN CHAR, SINCE 1R- = 1R++1
          SA6    INT.CHR-2
* PREPARE X2
          BX2    X2-X5       ABS(X2)
          PX2    X2
          NX2    X2          FLOAT X2
* INVARIANT: SHIFT THAT WILL POSITION X3 IS (INTSIZE+X6)*4 
          MX3    0           OUTPUT REGISTER
          SX6    -INTSIZE    - NUMBER OF LEADING SPACES
*
          SX4    10D
          PX4    X4
          NX4    X4          FLOAT 10D 
 INT.LOOP FX7    X2/X4       X2 // 10
          UX7    B5
          LX7    B5
          PX7    X7
          NX7    X7          ROUND X7
          FX5    X7*X4       X2 // 10 * 10
          FX5    X2-X5       DIGIT, FLOATING
          UX5    B5
          LX5    B5          ENTIER X5 
          BX2    X7          REMAINDER 
          BX3    X3+X5       ENTER CHAR
          LX3    -4          REMOVE
          SX6    X6+B1       COUNT IT
          NZ,X2  INT.LOOP
*
          SA6    A6+B1       INT.CHAR-1, - NUMBER OF LEADING SPACES
          SB5    INTSIZE+X6
          SB5    B5+B5
          SB5    B5+B5       (INTSIZE+B5)*4
          LX6    X3,B5       POSITION
          SA6    A6-B3       INT.CHAR-4
          SX6    B5-4        SHIFT - 4 
          SA6    A6+B1       INT.CHAR-3
          EQ     INT.CHR
          SPACE  10,10
* LINK POSSIBLE SUBPROGRAMS         ************************************
 LINKSUBS JP     *+1S17      LINK SUBPROGRAMS, DURING INITIALIZATION 
          QUAL   LINKSUBS
          SA1    CA.ADDR     @ COMM.AREA OF MAIN 
          SA2    X1+CA.SUBP  @ LIST OF SUB-PROGRAMS
 LINKSUB  SA3    X2          NEXT IN LIST
          ZR,X3  LINKSUBS    LIST EXHAUSTED
* X3 CONTAINS ENTRY POINT OF SUBPR.
          SA3    X3+B1       DIRTY DIGGING IN CODE
          LX3    30          RESTRICTED AREA
          SX3    X3          AUTHORIZED PERSONNEL ONLY
* X3 CONTAINS @ COMM.AREA OF SUBPR.
 
          SA4    X1+CA.FILES 
          SA5    X3+CA.FILES 
          SB5    FILECHN
          RJ     CHAIN       LINK FILES
 
          SA4    X1+CA.LIST
          SA5    X3+CA.LIST
          SB5    []LINK
          RJ     CHAIN       LINK LISTS
 
* GET NEXT SUBPROGRAM:
          SX2    X2+B1
          EQ     LINKSUB
 
 CHAIN    JP     *+1S17
* X4 CONTAINS BEGIN OF 1ST CHAIN, A4 ADDRESS BEGIN 1ST CHAIN
* X5 CONTAINS BEGIN OF 2ND CHAIN, B5 CONTAINS THE OFFSET.
          SX6    X4          ADDRESS ONLY
          ZR,X6  FOUND       FOUND END OF CHAIN
          SA4    X6+B5       ADDRESS OF NEXT IN CHAIN
          EQ     CHAIN+1     AND TRY AGAIN
 FOUND    BX6    X4+X5       OLD BITS FROM X4 AND ADDRESS FROM X5
          SA6    A4          AND LINK. 
          EQ     CHAIN
          QUAL * LINKSUBS
          SPACE  10,10
* MESSAGE                           ************************************
* MESSAGE BUFFER ROUTINES, USED BY 'ERROR' AND 'ERREXT'
* WHILE HANDLING THE MESSAGE BUFFER, B6 CONTAINS THE ADDRESS OF THE
* WORD UNDER CONSTRUCTION AND B7 CONTAINS THE SHIFT THAT WILL CORRECTLY
* POSITION THE NEXT CHARACTER.
          QUAL   MSBUFF
 
* MSALFSTR
 MSALFSTR JP     *+1S17      ALEPH STRING TO MSBUFF, @ IN X1
*
*'ACTION' MS ALFSTR + >ST - WC - ADDR - WORD:
 ST       =      1           X.ST, ADDRESS OF STRING
 WC       =      4           B.WC, WORD COUNT
 ADDR     =      2           A.ADDR, ADDRESS OF WORD; X.ADDR, WORD
*  GET WORD COUNT + WC, MINUS + ST + WC + ADDR, M[ADDR] -> WORD,
*   (WORDS - CC:
 CC       =      5           B.CC, CHARACTER COUNT
*    WC = 0, GET CHAR COUNT + CC, MS WORD + WORD + CC;
*    MS WORD + WORD + 8, DECR + WC, INCR + ADDR, M[ADDR] -> WORD,
*      :WORDS).
*
*'ACTION' MS WORD + >WORD + >CNT - CHAR:
*  CNT = 0;
*  LEFT CIRC + WORD + 7, EXTRACT BITS + WORD + 6 + CHAR,
*  MS CHAR + CHAR, DECR + CNT, :MS WORD.
*
*$ IMPLEMENTED VERSION:
*'ACTION' MS ALFSTR + >ST - WC - ADDR - WORD:
*  GET WORD COUNT + WC, MINUS + ST + WC + ADDR, M[ADDR] -> WORD,
*   (WORDS - CC:
*    (WC = 0, GET CHAR COUNT + CC; 8 -> CC),
*    MS WORD + WORD + CC,
*    (WC = 0; DECR + WC, INCR + ADDR, M[ADDR] -> WORD, :WORDS)
*   ).
*
 
          SA5    X.ST        LENGTH IN BIT 10 : 0
          AX5    3           WORD COUNT IN BIT 7 : 0
          MX4    -8          WHICH IS 8 BITS
          BX5    -X4*X5      WORD COUNT ONLY
          SB.WC  X5          GET WORD COUNT + WC,
          IX5    X.ST-X5     MINUS + ST + WC
          SA.ADDR X5                         + ADDR, M[ADDR] -> WORD,
 WORDS    BSS    0 
          SB.CC  8           JUST IN CASE
          NZ,B.WC EOSETCC    WC = 0,
          MX5    -3          GET
          BX5    -X5*X.ADDR      CHAR COUNT
          SB.CC  X5                         + CC;
 EOSETCC  BSS    0           ),
 MSWORD   BSS    0           MS WORD + >WORD + >CC - CHAR: 
          ZR,B.CC EOMSWRD    CC = 0;
          LX.ADDR 7          LEFT CIRC + WORD + 7,
          MX5    -6          EXTRACT BITS + WORD + 6
          BX1    -X5*X.ADDR                          + CHAR,
          RJ     MSCHAR      MS CHAR + CHAR,
          SB.CC  B.CC-B1     DECR + CC,
          EQ     MSWORD      :MS WORD
 EOMSWRD  BSS    0           .
          ZR,B.WC EOMSALF    WC = 0;
          SB.WC  B.WC-B1     DECR + WC,
          SA.ADDR A.ADDR+B1  INCR + ADDR, M[ADDR] -> WORD, 
          EQ     WORDS       :WORDS
 EOMSALF  EQU    MSALFSTR    .
* END OF MSALFSTR
 
*MSBEGIN 
 MSBEGIN  JP     *+1S17      INITIALIZES POINTERS FOR MS BUFFER HANDLING
          SB6    MSBUFF-1
          RJ     MSCLEAR
          EQ     MSBEGIN
 
*
 MSCHAR   JP     *+1S17      ADDS CHAR IN X1 TO BUFFER
          PL,B7  ROOM
          RJ     MSCLEAR
 ROOM     SA5    B6
          LX6    X1,B7
          SB7    B7-6
          BX6    X6+X5       ENTER CHAR
          SA6    A5
          EQ     MSCHAR
 
*
 MSCLEAR  JP     *+1S17      CLEARS NEXT WORD OF BUFFER
          SX6    B6-MSBUFF   +0, +1, +2, +3, +4
          AX6    2           +0, +0, +0, +0, +1
          SB6    -B6         -0, -1, -2, -3, -4 - MSBUFF
          SB6    B6+X6       -0, -1, -2, -3, -3 - MSBUFF
          SB6    B1-B6       +1, +2, +3, +4, +4 + MSBUFF, NO OVERFLOW
          MX6    0 
          SA6    B6          CLEAR WORD
          SB7    9*6
          EQ     MSCLEAR
 
*MSEND
 MSEND    JP     *+1S17      END OF MESSAGE, DISPLAY
          RJ     MSCLEAR     GIVE ENOUGH ZEROES
          MESSAGE MSBUFF,LOCAL,R
          EQ     MSEND
 
* MSINT
 MSINT    JP     *+1S17      DECIMAL INT IN X1 TO MSBUFF
          BX2    X1
          RJ     INT.CHR     INFO ABOVE INT.CHR
          SA1    INT.CHR-2   SIGN
          RJ     MSCHAR
          SA5    A1-B1       SHIFT
          SA4    A5-B1       WORD
          SB5    X5
          MX2    -4          MASK
 MSINT.L  BSS    0 
          AX3    X4,B5       POSITION
          BX1    -X2*X3      CHAR
          SB5    B5-4
          SX1    X1+1R0      DISPLAY CODE
          RJ     MSCHAR
          PL,B5  MSINT.L
          EQ     MSINT
* END OF MSINT
 
* MSOCT
 OCTRET   SX1    1RB
          RJ     MSCHAR
*         EQ     MSOCT
 MSOCT    JP     *+1S17      OCTAL INT IN X1 TO MSBUFF
          BX2    X1          FREE X1 FOR CALLS OF MSCHAR
          SB5    60/3
          BX3    X2
          AX3    18
          NZ,X3  OCTCH       MORE THAN 18 BITS
          LX2    42          DISCARD
          SB5    B5-42/3             42 BITS
          BX3    X2
          AX3    6+42
          NZ,X3  OCTCH       MORE THAN 6 BITS
          LX2    12          DISCARD
          SB5    B5-12/3             12 BITS
 OCTCH    BSS    0 
          SB5    B5-B1
          LX2    3 
          MX3    -3
          BX3    -X3*X2      NEXT CHAR 
          SX1    X3+1R0
          RJ     MSCHAR
          NZ,B5  OCTCH
          EQ     OCTRET
* END OF MSOCT
 
* MSTAG
 MSTAG    JP     *+1S17      WRITES THE FIRST 7 CHARS (OR LESS) OF THE
                             WORD IN X1 TO THE MESSAGE BUFFER
          MX6    7*6
          BX6    X6*X1
          SA6    =SMS.SCR
          SX1    A6
          RJ     MSTEXT
          EQ     MSTAG
* END OF MSTAG
 
* MSTEXT 
 MSTEXT   JP     *+1S17      WRITES TEXT THE ADDRESS OF WHICH IS IN X1
                             TO THE MSBUFF (B6, B7)
          SA2    X1-1        PRE-POINTER FOR READING
          MX3    6           MASK
 MSTEXTW  SA2    A2+B1       WORD
          SB5    -10         WHICH IS FULL
 MSTEXTCH BX1    X3*X2       CHARACTER 
          ZR,X1  MSTEXT      STOPS ON CHARACTER 00B
          LX1    6 
          LX2    6 
          SB5    B5+B1       COUNT IT
          RJ     MSCHAR      WRITE IT
          NG,B5  MSTEXTCH
          EQ     MSTEXTW
* END OF MSTEXT
 
*
 MSBUFF   BSS    5           40 CHARACTERS MAXIMUM
          QUAL * MSBUFF
 
 MSALFSTR =      /MSBUFF/MSALFSTR
 MSBEGIN  =      /MSBUFF/MSBEGIN
 MSCHAR   =      /MSBUFF/MSCHAR
 MSEND    =      /MSBUFF/MSEND
 MSINT    =      /MSBUFF/MSINT
 MSOCT    =      /MSBUFF/MSOCT
 MSTAG    =      /MSBUFF/MSTAG
 MSTEXT   =      /MSBUFF/MSTEXT
          SPACE  10,10
* INTEGER OVERFLOW                  ************************************
          ENTRY  OVFL
 OVFL     ERROR  (INTEGER OVERFLOW),D1 
          SPACE  10,10
* PARAMETERS FROM CONTROL CARD      ************************************
*
* THE AREA OF THIS ROUTINE WILL BE USED BY 'DUREGS' FOR DUMPING
* THE REGISTERS. CONSEQUENTLY, THIS ROUTINE MUST NEVER BE SHORTER THAN
* 25B WORDS, AND ITS OWN ERROR MESSAGES MUST BE AT ITS END.
*
 PARAMS   JP     *+1S17      RJ ENTRY
          QUAL   PARAMS
*
* DATE: 1974/9/3.
*
* THIS ROUTINE ANALYSES THE CONTROL CARD PARAMETER LIST OF A CALL TO 
* AN ALEPH PROGRAM AND CHANGES LFN'S ACCORDINGLY.
*
* EACH PARAMETER MUST BE OF THE FORM  'IDF=REPL' . FOR EACH SUCH PARA-
* METER THE FET LIST IS SEARCHED AND THE LFN IN THE FET IDENTIFIED BY
* 'IDF' WILL BE REPLACED BY 'REPL'.
*
* THE ADDRESS OF THE FIRST FET IS EXPECTED IN X1.
* THE ADDRESS OF THE FOLLOWING FET IS EXPECTED IN BITS 17:0 OF THE WORD
* AT X1+FILECHN.
* THE FET IDF IS IN BITS 59:18 OF THE WORD AT X1+FILECHN.
* THE LFN IS IN BITS 59:18 OF THE WORD AT X1.
*
* A PARAMETER OF THE FORM 'IDF=0' WILL CAUSE THE NAME IN THE FET TO BE
* ZEROED OUT.
*
* SEVERAL TESTS ON CORRECTNESS ARE INCLUDED.
*
* IN ALEPH THE ALGORITHM RUNS AS FOLLOWS;
*
* 'ACTION' PARAMS - PARPNT - IDF - REPL:
*   FILES -> HANDLE, 0 -> PARPNT,
*   0 -> PARPNT,
*   (PARS: IS PARAMS + PARPNT + IDF + REPL,
*               PROCESS + HANDLE + IDF + REPL, :PARS;
*          CHECK NAMES + HANDLE).
*
* 'PREDICATE' IS PARAMS + >PARPNT> + IDF> + REPL>
*              - IDF TAIL - REPL TAIL: 
*   $ FILLS IDF AND REPL, CHECKS THE PARAMETER FORM AND RESETS PARPNT $
*   ONE*PAR[PARPNT] -> IDF, TWO*PAR[PARPNT] -> REPL, NEXT + PARPNT,
*     LAST 18 BITS + IDF + IDFTAIL, CLEAR LAST 18 BITS + IDF,
*     LAST 18 BITS + REPL + REPL TAIL, CLEAR LAST 18 BITS + REPL,
*      ( IDF = 0, -;
*        ( IDF TAIL = /=/; ERROR), ( REPL TAIL = 0, ERROR; +)).
*
* 'ACTION' PROCESS + >HANDLE + >IDF + >REPL - DONE:
*   FALSE -> DONE, 
*   (PROCREP:
*     HANDLE = NIL;
*     (IDF*FET[HANDLE] = IDF, $ FOUND $  (IS + DONE, ERROR; +),
*       TRUE -> DONE, INSERT + REPL + HANDLE;
*      +), CHAIN*FET[HANDLE] -> HANDLE, :PROCREP).
*
* 'ACTION' INSERT + >REPL + >HANDLE:
*     REPL -> NAME*FET[HANDLE] $ BITS 59:18 ONLY $.
*
* 'ACTION' CHECK NAMES + >HANDLE - NAME:
*   HANDLE = NIL;
*   NAME*FET[HANDLE] -> NAME,
*    (NAME = /0/, 0 -> NAME * FET[HANDLE] $ FILE QUENCHED $;
*      (LEGAL + NAME; ERROR),
*      ( - HANDLE2:
*         CHAIN*FET[HANDLE] -> HANDLE2,
*         (CHECKREP:
*            HANDLE2 = NIL;
*            NAME*FET[HANDLE2] = NAME, ERROR;
*            CHAIN*FET[HANDLE2] -> HANDLE2, :CHECKREP)
*    ) ),
*    CHAIN*FET[HANDLE] -> HANDLE, :CHECK NAMES.
*
* 'QUESTION' LEGAL + >NAME - CHAR:
*   NEXT CHAR + NAME + CHAR, (LSEQ + CHAR + /Z/; ERROR),
*    (NAMETAIL:
*      NEXT CHAR + NAME + CHAR,
*       (CHAR = 0, (NAME = 0; ERROR);
*        (LSEQ + CHAR + /9/; ERROR), :NAMETAIL)).
*
* 'FUNCTION' NEXT CHAR + >NAME> + CHAR>:
* $ GETS NEXT CHARACTER INTO 'CHAR' AND REMOVES IT FROM 'NAME' $ + . 
*
* REGISTER ASSIGNMENT:
 HANDLE   =      4           B4, ORIGINAL REMAINS IN X1
 HANDLE2  =      5           B5 IN 'CHECK NAMES' 
 DONE     =      5           B5 IN 'PROCESS'
 IDF      =      2           X2 IN 'IS PARAMS' AND 'PROCESS'
 NAME     =      2           X2 IN 'CHECK NAMES' 
 REPL     =      3           X3
*FREE     =      4           X4 FREE
*SCRATCH  =      5,6,7       X5, X6, X7 ARE USED FOR SCRATCH
 PARPNT   =      REPL        A.REPL
*
 PARSEPEQ =      02          '=' AS SEPARATOR ON CC
*
* THE TEXT:
*
          SA1    CA.ADDR
          SA1    X1+CA.FILES FILES -> HANDLE
          SA.PARPNT 1        INIT PARPNT
 PARS     BSS    0 
*IS PARAMS
          SA.IDF A.REPL+B1   GET TWO WORDS
          SA.REPL A.IDF+B1   AND RESET PARPNT.
          MX6    -18
          MX7    -18
          BX6    -X6*X.IDF   IDF TAIL
          BX7    -X7*X.REPL  REPL TAIL 
          BX.IDF X.IDF-X6    IDF
          BX.REPL X.REPL-X7  REPL
          ZR,X.IDF ENDPARS
          SX6    X6-PARSEPEQ IS = ?
          NZ,X6  ERRCCBAD
          ZR,X7  ERRCCBAD
*
          SB.HANDLE X1
*PROCESS 
          SB.DONE B0
 PROCREP  ZR     B.HANDLE,ENDPROC
          SA5    B.HANDLE+FILECHN
          MX6    -18
          BX6    X6*X5       IDF OF FET
          BX6    X6-X.IDF
          NZ,X6  CHAIN
          NZ B.DONE,ERRDIDF
          SB.DONE B1
*INSERT   BSS    0 
          SA5    B.HANDLE    FILE NAME 
          MX6    -18
          BX6    -X6*X5      LAST 18 BITS OF WORD 0 IN FET 
          BX6    X6+X.REPL
11.22.36.**,MOMENTJE..

          SA6    A5          WRITE BACK
*         EQ     CHAIN
 CHAIN    SA5    B.HANDLE+FILECHN
          SB.HANDLE X5
          EQ     PROCREP
*ENDPROC  EQ     PARS
 ENDPROC  =      PARS
 ENDPARS  BSS    0 
          SB.HANDLE X1
 CHECKNMS BSS    0 
          ZR B.HANDLE,PARAMS RETURN FROM 'PARAMS'
          SA.NAME B.HANDLE   FET NAME
          MX6   -18
          BX.NAME X6*X.NAME  GET NAME
          SX5    1R0
          LX5    -6          1L0
          BX5    X.NAME-X5   0 IF NAME WAS '0'
          NZ,X5  LEGAL
          MX6    0           CLEAR
          SA6    B.HANDLE    NAME IN FET
          EQ     ENDCHREP
 LEGAL    BSS    0 
* CONSIDER A WORD TO CONSIST OF 10 6-BITS BYTES
          SA5    =7LZ999999  BIT 0 = 0 
          IX6    X5-X.NAME   SUBTRACTION MUST BE POSSIBLE WITHOUT
                             A BORROW, I.E. BIT 0 = BIT 0 IN X.NAME
          BX6    X6-X.NAME   BIT 0 MUST BE 0
          SA5    =01010101010101010101B BIT 0 = 1
          BX6    X6*X5       MUST BE ZERO
          NZ,X6  ERRIMPF
*
          SA5    B.HANDLE+FILECHN
          SB.HANDLE2 X5      INIT HANDLE2
 CHECKREP ZR B.HANDLE2,ENDCHREP
          SA5    B.HANDLE2   FILE NAME 
          MX6    -18
          BX5    X5*X6       NAME*FET[HANDLE]
          BX5    X5-X.NAME   COMPARE
          ZR,X5  ERRDFN
          SA5    B.HANDLE2+FILECHN
          SB.HANDLE2 X5      GET NEXT HANDLE2
          EQ     CHECKREP
 ENDCHREP SA5    B.HANDLE+FILECHN
          SB.HANDLE,X5
          EQ     CHECKNMS
*
 ERRCCBAD ERROR  (BAD CC PARAMETER),N.IDF
 ERRDIDF  ERROR  (DOUBLE IDF IN PROG),N.IDF
 ERRIMPF  ERROR  (IMPROPER FILE NAME),N.NAME
 ERRDFN   ERROR  (DUPLICATE FILE NAME),N.NAME
* END PARAMS.
          QUAL * PARAMS
          SPACE  10,10
          END
 
          IDENT  ALF.SC1     SCRATCH AREA FOR STRING HANDLING
          ENTRY  ALF.SC1
 ALF.SC1  BSS    6 
          END
 
          IDENT  BAC.HAR
          SST
          ENTRY  BAC.HAR
 BAC.HAR  JP     *+1S17      PUSHES BACK LAST CHARACTER
                             CAN BE USED FOR LAST CHARACTER ONLY
          SA5    X1+FILECH#  [54 : -6] 
          SX6    6 
          IX6    X5+X6       [60 : 0]
          SA6    A5
          EQ     BAC.HAR
          END
 
          IDENT  CLA4ROR     CLASS ERROR
          SST
          ENTRY  CLA4ROR
 CLA4ROR  ERROR  (NO CLASS APPLICABLE),D1
          END
 
          IDENT  COM7ING     ALEPH EXTERNAL RULE 
          SST
          ENTRY  COM7ING
 COM7ING  JP     *+1S17 COMPARE STRING + T1[] + >P1 + T2[] + >P2 + TRIT>
* COMPARES THE STRINGS (T1,P1) AND (T2,P2)
* TRIT:= 'IF' (T1,P1) > (T2,P2) 'THEN' 1
*       'ELIF' (T2,P2) > (T1,P1) 'THEN' -1 'ELSE' 0 'FI'
          MUSTBE X1,X2,(COMPARE STRING, BAD FIRST STRING POINTER)
          SA4    X1          OFFSET S1 
          BX6    X4          KEEP A COPY
          IX4    X2+X4       ADDRESS LAST WORD OF S1
          SA4    X4          LAST WORD 
          MX5    -11
          BX5    -X5*X4      LENGTH OF S1 IN CHARACTERS
          SB4    X5          SAVE IT
          AX5    3           LENGTH OF S1 IN WORDS
          IX2    X2-X5       PNT TO FIRST WORD OF S1
          MUSTBE X1,X2,(COMPARE STRING, BAD FIRST STRING)
          IX2    X2+X6       ADDRESS OF FIRST WORD
          SA2    X2          AND LOAD IT
* NOW WE ARRANGE THE SAME FOR THE SECOND STRING: 
 
          SA1    CA.ADDR     COMMUNICATION ADDRESS
          SA1    X1+CA.TEMP  POINTER TO LAST WORD OF S2
          SA5    =XTEMPIES                  $$$$$$$$$$$$$$$$$$$
          BX1    X1+X5       ONE OF THEM IS ZERO, WE THINK 
 
          MUSTBE X3,X1,(COMPARE STRING, BAD SEC. STRING POINTER)
          SA4    X3          OFFSET OF S2
          BX6    X4          KEEP A COPY
          IX4    X1+X4       ADDRESS OF LAST WORD S2
          SA4    X4          LAST WORD 
          MX5    -11
          BX5    -X5*X4      LENGTH OF S2 IN CHARACTERS
          SB5    X5          SAVE IT
          AX5    3                        IN WORDS
          IX1    X1-X5       PNT TO FIRST WORD OF S2
          MUSTBE X3,X1,(COMPARE STRING, BAD SEC. STRING)
          IX4    X1+X6       ADDRESS FIRST WORD OF S2
          SA4    X4          AND LOAD IT
* WE HAVE NOW INITIALIZED A2/X2 AND A4/X4
* THE NEXT SECTION CALCULATES THE LOOP PARAMETERS
          SX1    B4          LENGTH OF S1
          SX3    B5          LENGTH OF S2
          SX5    B4-B5       DIFFERENCE
          SB4    X5          WHICH SAVE
          AX5    60          PURE SIGN OF DIFFERENCE
          BX1    X5*X1       ZERO IF X1 >= X3
          BX3    -X5*X3      ZERO IF X1 < X3
          BX1    X1+X3       MINIMUM LENGTH
          AX1    3           IN WORDS
          SB5    X1          COUNTER
*
* LOOP ENVIRONMENT:
*   A2/X2 WORD IN FIRST STRING
*   A4/X4 WORD IN SECOND STRING
*   B5    NUMBER OF FULL WORDS TO BE COMPARED
*   B4    DIFFERENCE OF LENGTH, IN CHARACTERS
*
          ZR     B5,.LOOP7   PERHAPS NO WORD AT ALL
 LOOP7    LX2    -4          FIRST BIT 
          LX4    -4                    IS NOT A SIGN BIT
          IX1    X2-X4       COMPARE
          NZ     X1,DIFF
          SA2    A2+B1       NEXT OF S1
          SA4    A4+B1       NEXT OF S2
          SB5    B5-B1       COUNT
          NZ     B5,LOOP7
 .LOOP7   BSS    0 
*
* X2 AND X4 NOW CONTAIN THE LAST WORDS TO BE COMPARED. AT LEAST ONE OF
* THEM IS A GENUINE 'LAST WORD', SO ONLY THE FIRST 7 CHARACTERS CAN BE
* SIGNIFICANT. SOME OF THESE MAY NOT BE SIGNIFICANT, THEY WILL BE ZERO
* AND WILL COMPARE LOW, AS THEY SHOULD, UNLESS THE OTHER WORD CONTAINS
* ZERO-CHARACTERS IN THE CORRESPONDING PLACES. THE DECISION IS THEN
* MADE ON THE DIFFERENCE IN LENGTH, SAVED IN B4. 
*
          MX5    -11         MASK FOR 7 CHARACTERS
          BX2    X5*X2
          BX4    X5*X4
          LX2    -4
          LX4    -4
          IX1    X2-X4       COMPARE
          NZ     X1,DIFF
          SX1    B4          IF NO DIFFERENCE FOUND, GET DIFFERENCE
          ZR     X1,COM7ING    OR NOT, IN WHICH CASE GOTO DIFF
 DIFF     AX1    60          ALL SIGN BITS
          MX2    -1          -1
          BX1    -X1-X2      INVERT IF +0
          EQ     COM7ING
          END
 
          IDENT  CONV;
          SST
          ENTRY  CONV;
* ROUTINE TO BE USED BY THE CONVERTION ROUTINES TO ASCII AND FROM ASCII
 CONV;    JP     *+1S17      X1 CONTAINS CHARACTER, NORMALLY 0 : 63
                             X2 CONTAINS REPLACEMENT CHARACTER IF X1 BAD
                             X3 CONTAINS ADDRESS OF TABLE
*         SX1    X1          MUST BE POSITIVE
          SX4    X1-64       MUST BE NEGATIVE
          BX4    -X1*X4      MUST BE NEGATIVE
          AX4    60          MUST BE -0
          BX1    X4*X1       IF CONVERTIBLE
          BX2    -X4*X2      IF NON-CONVERTIBLE
          BX1    X1+X2
* NOW X1 IS BETWEEN 0 AND 63 
          MX2    -3
          BX2    -X2*X1      WORD NUMBER
          IX3    X3+X2       @ OF WORD WITH CHAR 
          SA3    X3          GET WORD
          BX1    X1-X2       CHAR NUMBER * 8
          AX2    X1,B2        * 2
          IX1    X1-X2        * 6
          SB4    X1
          AX1    X3,B4
          MX2    -6          0 : 63
          BX1    -X2*X1
          EQ CONV; 
          END
 
          IDENT  DATE
          SST
          ENTRY  DATE
 DATE     JP     *+1S17      'FUNCTION' DATE + YEAR> + MONTH> + DAY>.
 RIGHT    =      1           YEAR
 MIDDLE   =      2           MONTH
 LEFT     =      3           DAY
 
          DATE   =SSTATUS
          SX7    1R0*10D+1R0 '00'
          SA4    STATUS
          RJ     CONV        X5:= RIGHT ITEM
          IX.RIGHT X5-X7
          RJ     CONV        X5:= MIDDLE ITEM
          IX.MIDDLE X5-X7
          RJ     CONV        X5:= LEFT ITEM
          IX.LEFT X5-X7
          SX1    X1+1900     ADD CENTURY
          EQ     DATE        RETURN
 
 CONV     JP     *+1S17
          AX4    6           REMOVE RUBBLE
          MX6    -6
          BX5    -X6*X4      UNIT DIGIT = B
          AX4    6 
          BX6    -X6*X4      TEN  DIGIT = A
          AX4    6 
          LX6    1           2A
          IX5    X6+X5       2A+B
          LX6    2           8A
          IX5    X6+X5       10A+B
          EQ     CONV
          END
 
          IDENT  DIVREM
          SST
          ENTRY  DIVREM
 DIVREM   JP     *+1S17      DIVREM + >A + >B + Q> + R>:
          ZR     X2,ERRDIV   FOR B = 0 
          BX4    X1          SAVE A
          BX5    X2          SAVE B
          PL     X1,APOS     FOR POSITIVE A, SKIP ADJUSTING
          MX3    -1          -1
          IX1    X1-X3       A + 1
          BX3    X2          COPY B
          AX3    60          SIGN(B) * 0
          BX3    X2-X3       ABS(B)
          IX1    X1-X3       A + 1 - ABS(B)
 APOS     IX1    X1/X2,B5    Q:= (A + 1 - ABS(B)) / B
          MX3    0 
          IX1    X1+X3       AVOID -0
          BX3    X1          PROTECT X1
          IX3    X5*X3       B * Q
          IX2    X4-X3       R:= A - B*Q
          EQ     DIVREM
 ERRDIV   ERREXT (DIVREM, ZERO DIVIDE),D1
          END
 
          IDENT  EXTEND
          SST
* COMMUNICATION VARIABLES           ************************************
          ENTRY  NEW>>,ADDR>>,STACK<<,MAX>>
 NEW>>    BSS    1 
 ADDR>>   BSS    1 
*
 <>RTS    =      2           PSEUDO-CALIBRE OF THE RUN-TIME STACK
*
          SPACE  10,10
* INITIALIZATION                    ************************************
          ENTRY  INITEXT
 INITEXT  JP     *+1S17      INITIALIZE FLOATING LIST ADMINISTRATION 
* LOOP FOR UPDATING THE STRUCTURE OF THE LIST ADM CHAIN
          SA1    CA.ADDR
          SX4    X1+CA.LIST-[]LINK PRE ADDRESS
          SX6    B0          INITIAL BACK LINK
 UPD      SA4    X4+[]LINK
          SX4    X4          REMOVE BACK POINTER 
          ZR     X4,UPD.
*
          SA5    X4+[]LINK   INSERT BACK LINK
          LX6    30
          BX6    X5+X6       COMBINE WITH EXISTING LINK
          SA6 A5 X4+[]LINK   WRITE BACK
          SX6    X4          UPDATE BACK LINK
*
          SA5    X4+[]HIST
          NZ,X5  UPD         ELSE, IF NON-FLOATING STACK,
          MX7    -1          -1
          SA7 A5 []HIST
          EQ     UPD
 UPD.     BSS    0 
*
* INITIALIZE RT STACK ADM:
          SA1    RA.LWP      POINTER TO FIRST FREE WORD
          SX6    X1-1        POINTER TO END OF CODE
          SA6    ALFSTACK+[]LSR
          SA6    ALFSTACK+>> 
          SB6    X6          STACK POINTER
          SA6    ALFSTACK+<<PRE
          SA6    ALFSTACK+>>MAX
          SB7    X6          STACK LIMIT
*
          SX6    X6+<>RTS    <<PRE + <> = <<
          SA6    ALFSTACK+<< 
*
* LINK RUN-TIME STACK ADM INTO CHAIN
          SA1    CA.ADDR     @ OF COMM. AREA
          SA1    X1+CA.LIST
          SX6    ALFSTACK    @ OF RT STACK
          SA6    A1          INTO COMM. AREA.
*
          SX7    X1          FORWARD POINTER TO FIRST LIST,
                             BACKWARD POINTER = NIL
          SA7    ALFSTACK+[]LINK IS CORRECT CHAINING FOR RT STACK
*
          ZR,X1  INITEXT     EITHER THERE IS NO FIRST LIST, OR:
          SA1    X1+[]LINK   LINK WORD OF FIRST LIST
          LX6    30          CHAINED BACKWARD
          BX6    X1+X6       TO RT STACK
          SA6    A1
*
          EQ     INITEXT
          SPACE  10,10
* LIST ADM FOR RUN-TIME STACK: *RTS ************************************
*
          CON    1R**1S53+1RR*1S46+1RT*1S39+1RS*1S32+4 []NAME
          CON    10          []HIST
          CON    0           []AIM
          BSS    1           []LSR
          BSS    1           []LINK
          CON    <>RTS       <>
          BSS    1           <<
          BSS    1           >>, B6
          BSS    1           <<PRE, STACK<<
          BSS    1           >>MAX, B7 
 ALFSTACK CON    0           OFFSET, DUMMY
*
 STACK<<  =      ALFSTACK+<<PRE
*
          SPACE  10,10
* STACK OVERFLOW                    ************************************
          ENTRY  STOVL
 STOVL    BSS    0 
*
* THE STACK OVERFLOW HANDLER ASSUMES THE CALL TO BE OF THE FORM
*
*     SX7  *+1   \   EQ  LAB 
*
* AND WILL RETURN TO THE WORD AT 'LAB' + 1.
*
          SA7    SAVPARS     SAVE THE REGS TO BE USED BY THE SYSTEM; 
          BX6    X1          THE SYSTEM DOES NOT USE =XTEMPIES, SO
          SA6    A7+B1       THERE IS NO NEED TO SAVE THEM 
          BX6    X2
          SA6    A6+B1
          BX6    X3
          SA6    A6+B1
          STARTPR 2          ANNOUNCE STACK OVERFLOW
          SX1    ALFSTACK    OFFENDING STACK
          RJ     REDIVIDE
          STOPPR 2           ANNOUNCE STACK OVERFLOW
          SA5    SAVPARS     RESTORE REGS
          BX7    X5
          SA1    A5+B1
          SA2    A1+B1
          SA3    A2+B1
          SA5    X7-1        * RETURN TO CALL
          SB5    X5+1        *
          JP     B5          *
*
 SAVPARS  BSS    4 
          SPACE  10,10
* EXTENSION ROUTINE                 ************************************
          ENTRY  EXTEND
 OLD>>    BSS    1 
*
 EXTEND   JP     *+1S17      + >A1 + >X1 #UBND + >X2 #SIZE 
                             SAVES A1
          SX6    A1
          IX7    X1+X2       NEW SOFT RIGHT
          SA6    ADDR>>
          SA4    A1+B2       GET SOFT MAX
          IX5    X4-X7
          SA7    NEW>>
          PL     X5,EXTEND
*
          SA7    A1          SET NEW >> IN ADM, SINGLE INSTRUCTION
          BX6    X1          AND SAVE OLD >>
          SA6    OLD>>
*
          STARTPR 3          ANNOUNCE EXTEND OVERFLOW
          SX1    A1->>       A1 WAS POINTER TO >>
          SA5    X1+[]HIST   HALT IF EXTEND ON FIXED STACK 
          NG     X5,VIRTOVFL        CANNOT BE SATISFIED
*
          RJ     REDIVIDE    LEAVES X1 INTACT
*
          SA1    X1+>>       A1
          SA5    OLD>>
          BX6    X5          RESTORE OLD >>
          SA6    A1          SINGLE INSTRUCTION
          STOPPR 3           ANNOUNCE EXTEND OVERFLOW
          EQ     EXTEND
*
 VIRTOVFL ERROR  (VIRTUAL ADDRESS SPACE EXHAUSTED),L1
*
          SPACE  10,10
* REDIVIDE                          ************************************
 REDIVIDE JP     *+1S17
          SX6    X1           ADM OF STACK
          SA6    ADM
          DOWNCPU
* SAVE AND RESET A0,B6,B7 FOR REDIV
          SX6    A0-0
          SA6    SAVEA0
          SA0    -B1
          SX6    B6
          SA6    ALFSTACK+>> 
          SB6    =XRDV;ST-1
          SB7    =XRDV;ST.-1 
*
 +        SX7    *+1
          EQ     =XRED;DIV
* RESTORE A0,B6,B7 FOR ALEPH 
          SA5    SAVEA0
          SA0    X5-0        PRESERVE -0
          SA4    ALFSTACK+>> 
          SA5    ALFSTACK+>>MAX
          SB6    X4
          SB7    X5
*
          UPCPU
          SA1    ADM         RESTORE X1
          EQ     REDIVIDE
*
 ADM      BSS    1 
 SAVEA0   BSS    1           TO PREVENT MESSY ERROR MESSAGES
*
          SPACE  10,10
* MOVE + >N + >FROM + >TO           ************************************
          ENTRY  MOVE
*
* MOVES THE CONTENTS OF A PIECE OF CORE OF LENGTH 'N' STARTING AT 'FROM'
* TO THE AREA STARTING AT 'TO'.
* THE BODY CONSISTS OF A VERY TIGHT LOOP FOR THE ACTUAL TRANSPORT PLUS
* SOME INITIALIZATION FOR THAT LOOP.
*
          QUAL   MOVE
 ONE      SA4    X2
          BX6    X4
          SA6    X3
*         EQ     MOVE
 MOVE     JP     *+1S17      + >N + >FROM + >TO: 
          ZR,X1  MOVE        IF N = 0
          BX6    X1
          LX6    -1
          SB4    X6          B4 := N // 2
          ZR,B4  ONE         SINCE N /= 0
          IX4    X2-X3       NEGATIVE IF BACKWARDS TRANSPORT
          AX4    60
          SX5    B1          TENTATIVE STEP
          IX7    X1-X5       LENGTH - 1
          BX7    X7*X4       IF FORWARD THEN 0 ELSE LENGTH - 1
          BX5    X5-X4       IF FORWARD THEN 1 ELSE -1
          SB5    X5          ACTUAL STEP
          IX4    X2+X7       @ FIRST SOURCE
          IX5    X3+X7       @ FIRST DESTINATION 
          NG,X6  ODD         RIGHT-MOST BIT OF N 
*EVEN, N >= 2
          SB4    B4-B1       SINCE THE INITIALIZATION WILL MOVE 2 WORDS
          SA4    X4          FROM
          BX6    X4
          SA6    X5          TO
          SA5    A4+B5
          ZR,B4  RET
 LOOP     BSS    0           HERE STARTS THE LOOP. ENTRY CONDITIONS: 
                             (X5, A5) IS THE SECOND OF THE SOURCE PAIR,
                             A6 IS THE ADDRESS OF THE FIRST OF THE
                                DESTINATION PAIR,
                             THE WHOLE SOURCE PAIR IS READ, THE FIRST
                             WORD OF THE DESTINATION PAIR HAS BEEN
                             WRITTEN.
          SA4    A5+B5
          BX7    X5
          SA7    A6+B5
          SA5    A4+B5
 LOOP.    BSS    0           SOURCE PAIR IN X4, X5 AND A5. 
                             @ OF SECOND WORD OF DESTINATION IN A7
          BX6    X4
          SA6    A7+B5
          SB4    B4-B1       COUNT THE PAIR
          NZ,B4  LOOP
 RET      BSS    0           SAME CONDITIONS AS AT 'LOOP'
          BX7    X5
          SA7    A6+B5
          EQ     MOVE
 
 ODD      BSS    0           N >= 3
          SA4    X4          FROM
          BX7    X4
          SA7    X5          TO
          SA4    A4+B5
          SA5    A4+B5
          EQ     LOOP.
          QUAL * MOVE
 MOVE     =      /MOVE/MOVE
*MOVE     END
*
          SPACE  10,10
* GIVE UP, MEMORY FULL              ************************************
          ENTRY  GIVEUP
 GIVEUP   SA3    ADM         @ OF OFFENDING STACK
          SX4    ALFSTACK
          BX4    X3-X4       IS IT THE RUN-TIME STACK?
          ZR,X4  RTSTOVFL
          ERROR  (MEMORY EXHAUSTED - DURING EXTENSION),L3
 RTSTOVFL ERROR  (MEMORY EXHAUSTED - RT STACK OVERFLOW)
          SPACE  10,10
*  ATTEMPT TO EXTEND FIELD LENGTH   ************************************
          ENTRY  TRYEFL
 TRYEFL   JP     *+1S17        NEW RIGHT IN X1, RESULTING INCREASE IN X1
          SX6    X1+B1         NUMBER OF LOCATIONS
          LX6    30
          SA6    =SSTAT
          MEMORY CM,A6,R,,N
          MX6    0 
          SA6    =SSTAT
          MEMORY CM,A6,R
* UPDATE RA.LWP
          SA4    RA.LWP      OLD FL + BITS 59-18 
          SA5    =SSTAT
          AX5    30          NEW FL
          MX6    -18
          BX6    X6*X4       BITS 59-18
          BX4    X4-X6       OLD FL
          BX6    X6+X5       NEW FL + BITS 59-18 
          SA6 A4 RA.LWP
          IX1    X5-X4       SET RESULT TO NEW FL - OLD FL 
*
* UPDATE MAX>>
          SA4    MAX>>
          IX6    X5-X4       NEW FL - MAX>>, NEGATIVE IF MAX>> OK
          AX6    60
          BX4    X6*X4
          BX5    -X6*X5      OTHERWISE NEW FL SELECTED
          BX6    X4+X5
          SA6 A4 MAX>>       WINNER WRITTEN BACK 
*
          EQ     TRYEFL
*
 MAX>>    CON    0           MAX CM USED
*
          END
 
          IDENT  EXTEND=
          SST
          ENTRY  EXTEND=
 EXTEND=  JP     *+1S17      SEE MACRO 'EXTEND12'
          SA1    X1+>>       SPECIAL PARAMETER FOR 'EXTEND'
          RJ     =XEXTEND
          SA4    =XADDR>>
          SA5    =XNEW>>
          BX6    X5
          SA6    X4
          SX1    A1->>       RESTORE X1
          EQ     EXTEND=
          END
 
          IDENT  EXT5ITS
          SST
          ENTRY  EXT5ITS
 EXT5ITS  JP     *+1S17      EXTRACT BITS + >X + >N + Y>:
          SB5    X2
          EQ     B5,B0,EXT1
          SB4    B5-B1
          MX5    1 
          AX5    B4          LEFT-ALIGNED MASK OF N BITS
          LX5    B5          RIGHT-ALIGNED MASK OF N BITS
          BX1    X1*X5
          EQ     EXT5ITS
 EXT1     MX1    0 
          EQ     EXT5ITS
          END
 
          IDENT  FILESYS
          SST
 FILE     =      1           X.FILE, FOR VARIOUS ROUTINES
 
 CPC      MACRO  TYPE,OPTION 
 +        SB4    X.FILE      SAVE FILE ADDRESS
          SA1    X.FILE
          RJ     =XCPC
          VFD    60/TYPE_S42+1S40+OPTION_B
          SX.FILE B4         RESTORE X.FILE
 CPC      ENDM
          SPACE  10,10
* BACK FILE, REWINDS FILE           ************************************
 BAC2ILE  JP     *+1S17      BACK FILE + ''FILE: 
          ENTRY  BAC2ILE
          SA5    X.FILE      FILENAME
          ZR,X5  BAC2ILE     = DUMMY;
          SA5    X.FILE+FILETYPE
          LX5    SIGNBIT-READBIT
          NG,X5  NOEOR       IF READING, NO END OF RECORD
          SX2    B0          PUT END OF RECORD
          RJ     =XPUT8ORD   + FILE + 0
 NOEOR    BSS    0 
          CPC    7,150       CLOSE REWIND + FILE 
          RJ     /OPFLS/OPENIN OPEN INPUT FILE
          EQ     BAC2ILE     RETURN.
          SPACE  10,10
* CLOSE FILES                       ************************************
 CLOFLS   JP     *+1S17
         ENTRY   CLOFLS
* MAY NEVER CALL ERROR OR ERREXT
          QUAL   CLOFLS
          SA5    FLS.OK      IF FILES NOT OK,
          ZR,X5  RETURN      DON'T TRY TO CLOSE THEM.
*
          SA5    CA.ADDR
          SA.FILE X5+CA.FILES
 NEXTFLE  BSS    0 
          ZR,X.FILE RETURN
          SA5    X.FILE      FILE NAME 
          ZR,X5  GETNEXT     DUMMY FILE
          SA5    X.FILE+FILETYPE
          BX4    X5
          BX3    X4
          LX3    SIGNBIT-INPBIT
          LX4    SIGNBIT-OUTPBIT
          BX4    X3+X4       ZERO IF NEITHER INPUT NOR OUTPUT
          PL,X4  SCRATCH
 
          LX5    SIGNBIT-READBIT
          NG,X5  GETNEXT     NO WRITE FILE
 
          MX2    0           END OF RECORD
          RJ     PUT8ORD     WRITE EOR 
 GETNEXT  BSS    0 
          SA.FILE X.FILE+FILECHN
          SX.FILE X.FILE     ADDRESS PART ONLY
          EQ     NEXTFLE
 
 SCRATCH  BSS    0 
          CPC    7,174       CLOSE RETURN + FILE 
          EQ     GETNEXT
 
 RETURN   =      CLOFLS
          QUAL * CLOFLS
          SPACE  10,10
* CLOSE LINE                        ************************************
* THIS ROUTINE MAY ONLY BE CALLED IN PROTECTED STATE.
          ENTRY  CLOLINE
 CLOLINE  JP     *+1S17      CLOSE LINE, FET ADDRESS OF OUTPUT FILE IN
                             X.FILE WHICH REMAINS UNCHANGED.
          MX3    0           FOR A POSSIBLE CALL OF 'PUTWORD'
          SA5    X.FILE
          ZR,X5  CLOLINE     DUMMY FILE
          SA5    X.FILE+FILECH#
          SX5    X5-NEWSTAT
          ZR,X5  CLOLINE     FRESH RECORD
* SOME ACTION NECESSARY
          BX=    X1,X.FILE
          SA2    X.FILE+FILEWORD
          RJ     PUTWORD     WRITE WORD, X3 ALREADY SET
          MX5    -2*6
          BX5    -X5*X2
          ZR,X5  CLOLINE     LAST WORD ENDS IN 0000B
          MX2    0 
          RJ     PUTWORD     ELSE WRITE ZERO WORD
          EQ     CLOLINE
          SPACE  10,10
* EXTEND FILE,REVERT TO WRITING     ************************************
 EXT4ILE  JP     *+1S17      EXTEND FILE + ''FILE:
          ENTRY  EXT4ILE
          SA5    X.FILE      FILENAME
          ZR,X5  EXT4ILE     = DUMMY;
          ERROR  (EXTEND NOT IMPLEMENTED),F.FILE 
          EQ     EXT4ILE     RETURN.
          SPACE  10,10
* FILES OK FLAG                     ************************************
          ENTRY  FLS.OK
 FLS.OK   CON    0           ZERO = NOT OK, NON-ZERO = OK. 
          SPACE  10,10
* OPEN FILES                        ************************************
 OPFLS    JP     *+1S17
          ENTRY  OPFLS
          QUAL   OPFLS
          SA5    CA.ADDR
          SA.FILE X5+CA.FILES
 NEXTFLE  BSS    0 
          SX.FILE X.FILE     ADDRESS ONLY
          ZR,X.FILE OPFLS
          SA5    X.FILE      FILE NAME 
          ZR,X5  GETNEXT     DUMMY FILE
*
*'ACTION' OPEN FILE + ''FILE:
*  IS INPUT FILE + FILE, OPEN INPUT FILE + FILE; 
*  OPEN OUTPUT FILE + FILE.
*
*'ACTION' OPEN INPUT FILE + ''FILE:  $ ALSO FOR BACKFILE $ 
*  IS CHAR FILE + FILE, OPEN READ + FILE, SET READ MODE + FILE,
*    NEWSTAT -> STATUS;
*  OPEN REWIND READ + FILE, SET READ MODE + FILE, 0 -> STATUS,
*    INIT INPUT DATA FILE.
*
*'ACTION' OPEN OUTPUT FILE + ''FILE:
*  IS CHAR FILE + FILE, OPEN WRITE + FILE, CLEAR READ MODE + FILE,
*    NEWSTAT -> STATUS;
*  OPEN REWIND WRITE + FILE, CLEAR READ MODE + FILE, 0 -> STATUS,
*    INIT OUTPUT DATA FILE.
*
*OPENFILE JP      *+1S17         OPEN FILE + ''FILE
          SA5    X.FILE+FILETYPE IS INPUT FILE
          LX5    SIGNBIT+INPBIT                + FILE,
          PL,X5  OUTPUT
          RJ     OPENIN      OPEN INPUT FILE + FILE
          EQ     EOOPENFL    ;
 
 OUTPUT   BSS    0 
          RJ     OPENOUT     OPEN OUTPUT FILE + FILE
          EQ     EOOPENFL    .
          SPACE  10,10
 OPENIN   JP     *+1S17      OPEN INPUT FILE + ''FILE:
          SA5    X.FILE+FILETYPE IS
          LX5    SIGNBIT-CHDATBIT   CHARFILE + FILE
          NG,X5  NO.ICFL     ,
          RJ     CLEARFET
          CPC    4,100       OPEN READ + FILE,
          RJ     SETRM       SET READ MODE + FILE,
          SX6    NEWSTAT     NEWSTAT
          SA6    X.FILE+FILECH#      -> STATUS
          EQ     OPENIN      ;
 
 NO.ICFL  BSS    0 
          RJ     CLEARFET
          CPC    4,140       OPEN REWIND READ + FILE,
          RJ     SETRM       SET READ MODE + FILE,
          MX6    0           0
          SA6    X.FILE+FILECH# -> STATUS,
          RJ     INITIDFL    INIT INPUT DATA FILE + FILE
          EQ     OPENIN      .
          SPACE  10,10
 OPENOUT  JP     *+1S17      OPEN OUTPUT FILE + ''FILE:
          SA5    X.FILE+FILETYPE IS
          LX5    SIGNBIT-CHDATBIT   CHARFILE + FILE
          NG,X5  NO.OCFL     ,
          RJ     CLEARFET
          CPC    4,104       OPEN WRITE + FILE,
          RJ     CLEARRM     CLEAR READ MODE + FILE,
          SX6    NEWSTAT     NEWSTAT
          SA6    X.FILE+FILECH#      -> STATUS
          EQ     OPENOUT      ;
 
 NO.OCFL  BSS    0 
          RJ     CLEARFET
          CPC    4,144       OPEN REWIND WRITE + FILE,
          RJ     CLEARRM     CLEAR READ MODE + FILE,
          MX6    0           0
          SA6    X.FILE+FILECH# -> STATUS,
          RJ     INITODFL    INIT OUTPUT DATA FILE + FILE
          EQ     OPENOUT      .
          SPACE  10,10
 SETRM    JP     *+1S17      SET READ MODE + ''FILE:
          SA5    X.FILE+FILETYPE
          SX6    B1
          LX6    READBIT
          BX6    X6+X5
          SA6    A5
          EQ     SETRM
          SPACE  10,10
 CLEARRM  JP     *+1S17      CLEAR READ MODE + ''FILE:
          SA5    X.FILE+FILETYPE
          SX6    B1
          LX6    READBIT
          BX6    -X6*X5
          SA6    A5
          EQ     CLEARRM
          SPACE  10,10
 CLEARFET JP     *+1S17      CLEAR FET 
          SA5    X.FILE+B1   FIRST
          SX6    X5          BIT 17 - 0 ONLY
          SA6    A5+B1       IN
          SA6    A6+B1       OUT
          EQ     CLEARFET
         SPACE  10,10
          QUAL   INITIDFL
*
*'ACTION' INIT INPUT DATA FILE - LISTS PNT:
*  GET LISTS PNT + LISTS PNT,
*    (LISTS PNT = NUM PNT $ SIMPLE FILE $, SET SIMPLE BIT ;
*     TREAT LIST NAMES + LISTS PNT).
*
*'ACTION' TREAT LIST NAMES + >LISTS PNT - WORD:
 WORD     =      2           X.WORD
*  OBTAIN WORD + WORD,
*  (WORD = 0 $ END OF LIST NAMES ON FILE $;
*   LISTS PNT = NUM ZONE PNT, ERROR + TOO MANY LISTS;
*   FILL LIST BLOCK + LISTS PNT + WORD,
*     NEXT + FILE ADM + LISTS PNT, : TREAT LIST NAMES).
*
*'ACTION' FILL LIST BLOCK + >LISTS PNT + >WORD - PNT:
 PNT      =      4           B.PNT
*  LISTS PNT -> PNT,
*  FIND LIST BLOCK + PNT + WORD,
*  '<<PRE' * LIST ADM[ADDR*FILE ADM[PNT]] -> '<<PRE' * FILE ADM[PNT],
*  EXCHANGE BLOCKS + LISTSPNT + PNT.
*
*'ACTION' FIND LIST BLOCK + >PNT> + >WORD - WCNT - SIZE:
 SIZE     =      5           B.SIZE, IMPLEMENTED NEGATIVELY
*  EXTRACT LENGTH + WORD + CNT, 0 -> SIZE,
*  (PLACE WORD:
*    FIND PLACE FOR WORD + PNT + SIZE + WORD,
*       (WCNT = 0; 
*        DECR + WCNT, OBTAIN WORD + WORD, : PLACE WORD)
*  )#PLACE WORD.
*
*'FUNCTION' FIND PLACE FOR WORD + >PNT> + >SIZE> + >WORD - ADDR:
*$ THIS RULE IS GIVEN A POINTER TO A LIST BLOCK IN A
*$ FILE ADM. THE LAST 'SIZE' WORDS OF THE NAME OF THE
*$ LIST HAVE ALREADY BEEN MATCHED. THE RULE RETURNS
*$ A POINTER TO A (POSSIBLY DIFFERENT) LIST BLOCK WITH
*$ A LIST THE NAME OF WHICH ENDS WITH THE SAME
*$ 'SIZE' WORDS PRECEDED BY 'WORD'.
*  PLUS + ADDR * FILE ADM[PNT] + '[]NAME' + ADDR,
*  MINUS + ADDR + SIZE + ADDR,
*  (LIST ADM[ADDR] = WORD, $ WORD FITS $ INCR + SIZE;
*   FIND NEXT LIST + PNT + SIZE, : FIND PLACE FOR WORD).
*
*'FUNCTION' FIND NEXT LIST + >PNT> + >SIZE - PNT2:
 PNT2     =      6           X.PNT2
*$ FINDS THE NEXT LIST BLOCK THE NAME OF THE LIST OF WHICH 
*$ ENDS WITH THE SAME 'SIZE' WORDS.
*  PNT -> PNT2, NEXT + FILE ADM + PNT2,
*  (PNT2 = NUM ZONE PNT, ERROR + UNKNOWN LIST;
*   PARTIAL NAMES EQUAL + PNT + PNT2 + SIZE, PNT2 -> PNT;
*   PNT2 -> PNT, : FIND NEXT LIST).
*
*'QUESTION' PARTIAL NAMES EQUAL + >PNT + >PNT2 + >SIZE
*  - ADDR1 - ADDR2 - PNCNT:
*  PLUS + ADDR * FILE ADM[PNT] + '[]NAME' + ADDR1,
*  PLUS + ADDR * FILE ADM[PNT2] + '[]NAME' + ADDR2,
*  SIZE -> PNCNT,
*  (COMPARE:
*    PNCNT = 0;
*    LIST ADM[ADDR1] = LIST ADM[ADDR2],
*    DECR + ADDR1, DECR + ADDR2, DECR + PNCNT, : COMPARE). 
*
 INITIDFL JP     *+1S17      INIT INPUT DATA FILE
          LISTSPNT 5         GET LISTS PNT
          BX6    X5
          SA6    =SLISTSPNT  + LISTS PNT,
*SIMPLE FILE
          NUMZNPNT 5         X5:= NUM PNT
          IX5    X5-X6       LISTS PNT = NUM PNT 
          NZ,X5  TRLSTNMS    ,
          SA5    X.FILE+FILETYPE SET
          SX6    B1            SIMPLE
          LX6    SIMPBIT         BIT
          BX6    X6+X5             +
          SA6 A5 X.FILE+FILETYPE      FILE
          EQ     INITIDFL    ;
 
 TRLSTNMS BSS    0           TREAT LIST NAMES:
          BX=    1,FILE
          RJ     =XGETWORD   OBTAIN
          NZ,X3  ERRSHORT           + WORD,
          ZR,X2  EOTRNMS     WORD = 0; 
          SA4    LISTSPNT    LISTS PNT 
          NUMZNPNT 5         =
          IX4    X4-X5       NUM ZONE PNT,
          ZR,X4  ERRMANY     ERROR;
*FILLBLCK BSS    0           FILL LIST BLOCK:
          SA5    LISTSPNT    LISTS PNT 
          SB.PNT X5          -> PNT,
*FINDBLCK BSS    0           FIND LIST BLOCK:
          AX5    X.WORD,B3   EXTRACT LENGTH
          MX4    -8
          BX6    -X4*X5      + WORD
          SA6    =SWCNT      + WCNT,
          SB.SIZE B0         0 -> SIZE,
 PLACEWRD BSS    0 
 FINDPL   BSS    0           FIND PLACE FOR WORD:
          SA5    B.PNT       PLUS + ADDR * FILE ADM[PNT]
          SX5    X5+[]NAME   + '[]NAME' + ADDR,
          SA5    X5+B.SIZE   MINUS + ADDR + SIZE + ADDR,
          BX5    X5-X.WORD   LIST ADM[ADDR]
          NZ,X5  NOTFND      =
          NG,X5  NOTFND      WORD,
          SB.SIZE B.SIZE-B1  INCR + SIZE;
          EQ     EOFINDPL
 
 NOTFND   BSS    0 
 FINDNEXT BSS    0           FIND NEXT LIST:
          SX.PNT2 B.PNT+B2   PNT -> PNT2, NEXT + FILE ADM + PNT2,
          NUMZNPNT 5         NUM ZONE PNT
          IX5    X5-X.PNT2   = PNT2,
          ZR,X5  ERRUNKN     ERROR + UNKNOWN LIST;
*PARTNME  BSS    0           PARTIAL NAMES EQUAL:
          SA4    B.PNT       PLUS + ADDR * FILE ADM[PNT]
          SA4    X4+[]NAME   + '[]NAME' + ADDR1, (X4:= LIST ADM[ADDR1])
          SA5    X.PNT2      PLUS + ADDR * FILE ADM[PNT2]
          SA5    X5+[]NAME   + '[]NAME' + ADDR2, (X5:= LIST ADM[ADDR2])
          SX7    B.SIZE      SIZE -> PNCNT,
 COMPARE  BSS    0 
          ZR,X7  EOPARTNM    PNCNT = 0;
          BX5    X4-X5       LIST ADM[ADDR1]
          NZ,X5  EOPARTNM    =
          NG,X5  EOPARTNM    LIST ADM[ADDR2],
          SA4    A4-B1       DECR + ADDR1,
          SA5    A5-B1       DECR + ADDR2,
          SX7    X7+B1       DECR + PNCNT (NEGATIVE),
          EQ     COMPARE     : COMPARE.
 
 EOPARTNM BSS    0           X7 = 0 IF SUCCESS
          SB.PNT X.PNT2      PNT2 -> PNT,
          NZ,X7  FINDNEXT    : FIND NEXT LIST
          EQ     FINDPL      : FIND PLACE FOR WORD
 
 EOFINDPL BSS    0           PROPER PLACE FOR WORD FOUND.
          SA5    WCNT        WCNT
          ZR,X5  EOFINDBL    = 0;
          SX6    X5-1        DECR +
          SA6    A5          WCNT,
          BX=    1,FILE
          RJ     =XGETWORD   OBTAIN
          NZ,X3  ERRSHORT    + WORD,
          BX=    WORD,2
          EQ     PLACEWRD    : PLACEWORD.
 
 EOFINDBL BSS    0           @ OF PROPER LIST BLOCK IN B.PNT.
          SA5    B.PNT       ADDR * FILE ADM[PNT] -> X5,
          SA5    X5+<<PRE    '<<PRE' * LIST ADM[X5]
          BX6    X5          ->
          SA6    B.PNT+B1    '<<PRE' * FILE ADM[PNT],
          SA3    LISTSPNT    EXCHANGE
          SA4    X3          FIRST
          SA5    B.PNT       WORDS
          BX6    X4          OF THE BLOCKS
          SA6    A5          AT LISTS PNT
          BX7    X5          AND
          SA7    A4          AT PNT,
          SA4    A4+B1       EXCHANGE
          SA5    A5+B1       SECOND WORDS
          BX6    X4          OF THE BLOCKS
          SA6    A5          AT LISTS PNT
          BX7    X5          AND
          SA7    A4          AT PNT.
*EOFILLBL BSS    0           BLOCK AT LISTS PNT FILLED.
          SA5    LISTSPNT    NEXT
          SX6    X5+B2            + FILE ADM
          SA6    A5                           + LISTS PNT, 
          EQ     TRLSTNMS    : TREAT LIST NAMES. 
 
 EOTRNMS  EQU    INITIDFL
 
 ERRSHORT ERROR  (DATAFILE INCOMPLETE),F.FILE
 ERRUNKN  ERROR  (DATAFILE CONTAINS UNKNOWN LIST NAME),F.FILE
 ERRMANY  EQU    ERRUNKN     ?
          QUAL * INITIDFL
 INITIDFL =      /INITIDFL/INITIDFL
          SPACE  10,10
          QUAL   INITODFL
*
*'ACTION' INIT OUTPUT DATA FILE - PNT: 
*  GET LISTS PNT + PNT,
*   (PNT = NUM PNT $ SIMPLE FILE $, SET SIMPLE BIT + FILE; 
*    TREAT LIST ZONES + PNT, PUT WORD + FILE + 0 + 0).
 PNT      =      2           X.PNT
*
*'ACTION' TREAT LIST ZONES + >PNT:
*  PNT = NUM ZONE PNT;
*  TREAT LIST ZONE + PNT, NEXT + FILE ADM + PNT, 
*    : TREAT LIST ZONES.
*
*'ACTION' TREAT LIST ZONE + >PNT - ADDR:
*  ADDR * FILE ADM [PNT] -> ADDR $ LIST ADDRESS $,
*  '<<PRE' * LIST ADM [ADDR] -> '<<PRE' * FILE ADM [PNT],
*  WRITE NAME + ADDR.
 ADDR     =      4           B.ADDR
*
*'ACTION' WRITE NAME + >ADDR - WORD - CNT:
 WORD     =      2           X.WORD, FOR PUT WORD
 CNT      =      5           B.CNT
*  PLUS + ADDR + '[]NAME' + ADDR,
*  EXTRACT LENGTH + LIST ADM[ADDR] + CNT,
*  (NAME:
*    PUT WORD + FILE + LIST ADM[ADDR] + 0,
*     (CNT = 0;
*      DECR + CNT, DECR + ADDR, : NAME)
*  ).
*
 INITODFL JP     *+1S17      INIT OUTPUT DATA FILE
*GETLPNT  BSS    0 
          LISTSPNT PNT       GET LISTS PNT + PNT,
*SIMPLE FILE
          NUMZNPNT 5         X5:= NUM PNT
          IX5    X5-X.PNT    LISTS PNT = NUM PNT 
          NZ,X5  TRLSTZNS    ,
          SA5    X.FILE+FILETYPE SET
          SX6    B1            SIMPLE
          LX6    SIMPBIT         BIT
          BX6    X6+X5             +
          SA6 A5 X.FILE+FILETYPE      FILE
          EQ     INITODFL    ;
 
 TRLSTZNS BSS    0           TREAT LIST ZONES:
          NUMZNPNT 5         NUM ZONE PNT
          IX5    X5-X.PNT
          ZR,X5  EOTRZNS     PNT = NUM ZONE PNT; 
*TRLSTZN  BSS    0           TREAT LIST ZONE:
          SA5    X.PNT       ADDR * FILE ADM [PNT]
          SB.ADDR X5         -> ADDR,
          SA5    B.ADDR-B2   '<<PRE' * LIST ADM [ADDR]
          BX6    X5          ->
          SA6    X.PNT+B1    '<<PRE' * FILE ADM [PNT],
*WRTNAME  BSS    0           WRITE NAME:
          BX6    X2          SAVE
          SA6    =SSAVE      X2
          SB.ADDR B.ADDR+[]NAME ADDRESS OF NAME
          SA4    B.ADDR      LIST ADM[ADDR] -> X4
          AX4    3           EXTRACT LENGTH
          MX5    -8
          BX5    -X5*X4      + X4
          SB.CNT X5          + CNT,
 NAME     BSS    0 
          BX=    1,FILE
          SA2    B.ADDR      LIST ADM [ADDR]
          MX3    0           LEVEL
          RJ     =XPUTWORD   PUTWORD,
          ZR,B.CNT EOWRNME   CNT = 0;
          SB.CNT B.CNT-B1    DECR + CNT,
          SB.ADDR B.ADDR-B1  DECR + ADDR,
          EQ     NAME
 
 EOWRNME  SA2    =SSAVE      RESTORE X2
*EOTRZN   BSS    0 
          SX.PNT X.PNT+B2    NEXT + FILE ADM + PNT,
          EQ     TRLSTZNS
 
 EOTRZNS  BSS    0 
          BX=    1,FILE
          SX2    0 
          MX3    0 
          RJ     =XPUTWORD   PUTWORD + FILE + 0 + 0
          EQ     INITODFL
          QUAL * INITODFL
 INITODFL EQU    /INITODFL/INITODFL
 
          SPACE  10,10
 EOOPENFL BSS    0           END OF OPEN FILE
 GETNEXT  SA.FILE X.FILE+FILECHN
          EQ     NEXTFLE
          QUAL * OPFLS
          SPACE  10,10
* PUT END OF RECORD                 ************************************
          ENTRY  PUT8ORD
 PUT8ORD  JP     *+1S17      + ""FILE + >LEVEL
          SA5    X.FILE      FILENAME
          ZR,X5  PUT8ORD     = DUMMY;
          MX6    -4
          BX6    -X6*X2      LAST FOUR BITS OF LEVEL
          BX5    X2-X6       MUST BE ZERO
          NZ,X5  BADLEVEL    OTHERWISE ERROR
          SX6    X6+B1       PARAMETER 
          SA6    =SSAVE
          DOWNCPU
          SA5    X.FILE+FILETYPE
          LX5    SIGNBIT-READBIT
          NG,X5  READFL      READFILE
          LX5    READBIT-CHDATBIT
          NG,X5  DATAFILE
          RJ     =XCLOLINE
 DATAFILE SA3    SAVE        LEVEL
          RJ     =XPUTWORD
          SX6    NEWSTAT
          SA6    X.FILE+FILECH#  SET STATUS
          UPCPU
          EQ     PUT8ORD
 
 READFL   ERREXT (PUT END OF RECORD, NOT WHILE WRITING),F.FILE
 BADLEVEL ERREXT (PUT END OF RECORD, BAD LEVEL),(F.FILE,D2)
 
          END
 
          IDENT  FIR3RUE
          SST
          ENTRY  FIR3RUE
 FIR2     BSS    0           IN LAST 12 BITS
          NX4    B5,X1
          NE     B5,B4,FIR3  IF PRESENT
          MX0    1 
*         EQ     FIR3RUE
 FIR3RUE  JP     *+1S17      FIRST TRUE + >X + N>:
          MX0    0 
          NG     X1,FIR1
          BX2    X1
          AX2    12          FILLS WITH 0'S
          NX5,B5 X2
          SB4    48D
          EQ     B5,B4,FIR2  IN LAST 12 BITS
          SB4    SIGNBIT
          SX1    B4-B5
          EQ     FIR3RUE
 FIR1     SX1    WORDSIZE-1
          EQ    FIR3RUE
 FIR3     SB4    B4-B1       47
          SX1    B4-B5
          EQ     FIR3RUE
          END
 
          IDENT  FRO3CII
          SST
          ENTRY  FRO3CII
 FRO3CII  JP     *+1S17      FROM ASCII TO DISPAY CODE
          SX1    X1-40B      RELOCATE
          SX2    37B         QUESTION MARK
          SX3    TABLE
          RJ     =XCONV;
          EQ     FRO3CII
 
 TABLE    DATA   3020107443335155B
          DATA   3121110144345266B
          DATA   3222120263354764B
          DATA   6123130377364560B
          DATA   7524140472375653B
          DATA   6225150554404671B
          DATA   7626160673415767B
          DATA   6527170771425070B
          END

